"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[8096],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return m}});var s=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,s,r=function(e,n){if(null==e)return{};var t,s,r={},o=Object.keys(e);for(s=0;s<o.length;s++)t=o[s],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)t=o[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=s.createContext({}),d=function(e){var n=s.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},l=function(e){var n=d(e.components);return s.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return s.createElement(s.Fragment,{},n)}},h=s.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),h=d(t),m=r,p=h["".concat(c,".").concat(m)]||h[m]||u[m]||o;return t?s.createElement(p,a(a({ref:n},l),{},{components:t})):s.createElement(p,a({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,a=new Array(o);a[0]=h;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,a[1]=i;for(var d=2;d<o;d++)a[d]=t[d];return s.createElement.apply(null,a)}return s.createElement.apply(null,t)}h.displayName="MDXCreateElement"},8899:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return l},default:function(){return h}});var s=t(3117),r=t(102),o=(t(7294),t(3905)),a=["components"],i={title:"sleepy_discord/client.cpp"},c=void 0,d={unversionedId:"reference/Files/client_8cpp",id:"reference/Files/client_8cpp",title:"sleepy_discord/client.cpp",description:"Namespaces",source:"@site/docs/reference/Files/client_8cpp.md",sourceDirName:"reference/Files",slug:"/reference/Files/client_8cpp",permalink:"/sleepy-discord/docs/reference/Files/client_8cpp",tags:[],version:"current",frontMatter:{title:"sleepy_discord/client.cpp"},sidebar:"Reference",previous:{title:"include/sleepy_discord/channel.h",permalink:"/sleepy-discord/docs/reference/Files/channel_8h"},next:{title:"include/sleepy_discord/client.h",permalink:"/sleepy-discord/docs/reference/Files/client_8h"}},l=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Functions",id:"functions",children:[],level:2},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function hash",id:"function-hash",children:[],level:3}],level:2},{value:"Source code",id:"source-code",children:[],level:2}],u={toc:l};function h(e){var n=e.components,t=(0,r.Z)(e,a);return(0,o.kt)("wrapper",(0,s.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"namespaces"},"Namespaces"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Name"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),(0,o.kt)("h2",{id:"functions"},"Functions"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null}),(0,o.kt)("th",{parentName:"tr",align:null},"Name"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"constexpr unsigned int"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8cpp#function-hash"},"hash")),"(const char * key, unsigned int i =0)")))),(0,o.kt)("h2",{id:"functions-documentation"},"Functions Documentation"),(0,o.kt)("h3",{id:"function-hash"},"function hash"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"constexpr unsigned int hash(\n    const char * key,\n    unsigned int i =0\n)\n")),(0,o.kt)("h2",{id:"source-code"},"Source code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#if _MSC_VER && !__INTEL_COMPILER\n#pragma warning( disable: 4307 )  //ignore integer overflow, becuase we are taking advantage of it\n#endif\n\n#include <chrono>\n#include <functional>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <cstring>\n#include "client.h"\n#include "version_helper.h"\n//#include "json.h"\n#include "rapidjson/document.h"\n#ifdef SLEEPY_USE_HARD_CODED_GATEWAY\n    #include <cstring>\n#endif\n\nnamespace SleepyDiscord {\n    void BaseDiscordClient::start(const std::string _token, const char maxNumOfThreads, int _shardID, int _shardCount) {\n        if (!scheduleHandler) {\n            setError(CANT_SCHEDULE);\n            return;\n        }\n        \n        ready = false;\n        quiting = false;\n        bot = true;\n        setToken(_token);\n        if (_shardID != 0 || _shardCount != 0)\n            setShardID(_shardID, _shardCount);\n\n        messagesRemaining = 4;\n    }\n\n    BaseDiscordClient::~BaseDiscordClient() {\n        ready = false;\n        if (heart.isValid()) heart.stop();\n        stopReconnecting();\n    }\n\n    Response BaseDiscordClient::request(const RequestMethod method, Route path, const std::string jsonParameters,\n        const std::vector<Part>& multipartParameters, RequestCallback callback, const RequestMode mode\n    ) {\n        //check if rate limited\n        Response response;\n        const double currentTime = getEpochTimeSecond();\n        response.birth = currentTime;\n        Route::Bucket bucket = path.bucket(method);\n\n        bool shouldCallCallback = true;\n        const auto handleCallbackCall = [&]() {\n            if (shouldCallCallback && callback)\n                callback(response);\n        };\n        const auto handleExceededRateLimit = [=, &shouldCallCallback](double timeTilRetry) {\n            onExceededRateLimit(\n                rateLimiter.isGlobalRateLimited, timeTilRetry,\n                { *this, method, path, jsonParameters, multipartParameters, callback, mode },\n                shouldCallCallback\n            );\n        };\n\n        double nextTry = rateLimiter.getLiftTime(bucket, currentTime);\n        if (0 < nextTry) {\n            handleExceededRateLimit(nextTry - currentTime);\n            response.statusCode = TOO_MANY_REQUESTS;\n            onError(TOO_MANY_REQUESTS,\n                "Too many request going to " +\n                    std::string(getMethodName(method)) + " " +\n                    path.url());\n            handleCallbackCall();\n            return response;\n        }\n        {   //the { is used so that onResponse is called after session is removed to make debugging performance issues easier\n            //request starts here\n            Session session;\n            session.setUrl("https://discord.com/api/v10/" + path.url());\n            std::vector<HeaderPair> header = {\n                { "Authorization", bot ? "Bot " + getToken() : getToken() },\n                { "User-Agent", userAgent },\n            };\n            if (jsonParameters != "") {\n                session.setBody(&jsonParameters);\n                header.push_back({ "Content-Type"  , "application/json"                      });\n                header.push_back({ "Content-Length", std::to_string(jsonParameters.length()) });\n            } else if (0 < multipartParameters.size()) {\n                session.setMultipart(multipartParameters);\n                header.push_back({ "Content-Type", "multipart/form-data" });\n            } else {\n                header.push_back({ "Content-Length", "0" });\n            }\n            session.setHeader(header);\n\n            //Do the response\n            switch (method) {\n            case Post: case Patch: case Delete: case Get: case Put:\n                response = session.request(method);\n                break;\n            default: response.statusCode = BAD_REQUEST; break; //unexpected method\n            }\n\n            //rate limit check\n            if (response.header["X-RateLimit-Remaining"] == "0" && response.statusCode != TOO_MANY_REQUESTS) {\n                const std::string& resetAfter = response.header["X-RateLimit-Reset-After"];\n                const std::string& xBucket = response.header["X-RateLimit-Bucket"];\n                const double resetDelta = !resetAfter.empty() ? std::stod(resetAfter) : 5.0;\n                rateLimiter.limitBucket(bucket, xBucket, resetDelta + getEpochTimeSecond());\n                onDepletedRequestSupply(bucket, resetDelta);\n            }\n\n            //status checking\n            switch (response.statusCode) {\n            case OK: case CREATED: case NO_CONTENT: case NOT_MODIFIED: break;\n            case TOO_MANY_REQUESTS:\n                {   //this should fall down to default\n                    const std::string& resetAfterStr = response.header["X-RateLimit-Reset-After"];\n                    //the 5 is an arbitrary number\n                    double resetAfter = resetAfterStr != "" ? std::stod(resetAfterStr) : 5.0;\n                    rateLimiter.isGlobalRateLimited = response.header.find("X-RateLimit-Global") != response.header.end();\n                    rateLimiter.nextRetry = getEpochTimeSecond() + resetAfter;\n                    const std::string& xBucket = response.header["X-RateLimit-Bucket"];\n                    if (!rateLimiter.isGlobalRateLimited) {\n                        rateLimiter.limitBucket(bucket, xBucket, rateLimiter.nextRetry);\n                        onDepletedRequestSupply(bucket, resetAfter);\n                    }\n                    handleExceededRateLimit(resetAfter);\n                }\n            default:\n                {       //error\n                    const ErrorCode code = static_cast<ErrorCode>(response.statusCode);\n                    setError(code);     //https error\n                    if (!response.text.empty()) {\n                        //json::Values values = json::getValues(response.text.c_str(),\n                        //{ "code", "message" });   //parse json to get code and message\n                        rapidjson::Document document;\n                        document.Parse(response.text.c_str());\n                        if (!document.IsObject()) {\n                            onError(GENERAL_ERROR, "No error code or message from Discord");\n                            break;\n                        }\n\n                        auto errorCode = document.FindMember("code");\n                        auto errorMessage = document.FindMember("message");\n                        if (errorCode != static_cast<rapidjson::GenericValue<rapidjson::UTF8<>>::ConstMemberIterator>(document.MemberEnd())){\n                            std::size_t fullErrorMessageSize = 0;\n                            fullErrorMessageSize += path.getPath().length();\n                            fullErrorMessageSize += 1;\n                            fullErrorMessageSize += response.text.length();\n                            fullErrorMessageSize += 1;\n                            std::string message = (\n                                    errorMessage != static_cast<rapidjson::GenericValue<rapidjson::UTF8<>>::ConstMemberIterator>(document.MemberEnd())\n                                    ?\n                                        errorMessage->value.GetString()\n                                    :\n                                        ""\n                            );\n                            fullErrorMessageSize += message.length();\n                            std::string fullErrorMessage;\n                            fullErrorMessage.reserve(fullErrorMessageSize);\n                            fullErrorMessage += path.getPath();\n                            fullErrorMessage += \'\\n\';\n                            fullErrorMessage += response.text;\n                            fullErrorMessage += \'\\n\';\n                            fullErrorMessage += message;\n\n                            onError(\n                                static_cast<ErrorCode>(errorCode->value.GetInt()),\n                                std::move(fullErrorMessage)\n                            );\n                        } else if (!response.text.empty()) {\n                            onError(ERROR_NOTE, response.text);\n                        }\n                    }\n#if defined(__cpp_exceptions) || defined(__EXCEPTIONS)\n                            if (static_cast<int>(mode) & static_cast<int>(ThrowError))\n                                throw code;\n#endif\n                } break;\n            }\n\n            handleCallbackCall();\n        }\n        onResponse(response);\n        return response;\n    }\n\n    const Route BaseDiscordClient::path(const char * source, std::initializer_list<std::string> values) {\n        return Route(source, values);\n    }\n\n    std::shared_ptr<ServerCache> BaseDiscordClient::createServerCache() {\n        setServerCache(std::make_shared<ServerCache>());\n        return getServerCache();\n    }\n\n    void BaseDiscordClient::setServerCache(std::shared_ptr<ServerCache> cache) {\n        serverCache = cache;\n        if ((ready || !isBot()) && serverCache->size() == 0)\n            *serverCache = getServers().get<Cache>();\n    }\n\n    void BaseDiscordClient::onDepletedRequestSupply(const Route::Bucket&, double) {\n    }\n\n    void BaseDiscordClient::onExceededRateLimit(bool, double timeTilRetry, Request request, bool& continueRequest) {\n        bool shouldScheduleNewRequest =\n            static_cast<int>(request.mode) & static_cast<int>(AsyncQueue);\n        continueRequest = !shouldScheduleNewRequest;\n        if (shouldScheduleNewRequest) {\n            //since we are scheduling the request, I think we should make it async\n            request.mode = Async;\n            schedule(request, static_cast<time_t>(timeTilRetry * 1000.0));\n        }\n    }\n\n    void BaseDiscordClient::updateStatus(std::string gameName, uint64_t idleSince, Status status, bool afk) {\n        std::string statusString[] = {\n            "", "online", "dnd", "idle", "invisible", "offline"\n        };\n\n        sendL(json::createJSON({\n            { "op", json::integer(STATUS_UPDATE) },\n            { "d", json::createJSON({\n                {"since", idleSince != 0 ? json::UInteger(idleSince) : "null"},\n                {"game", gameName != "" ? json::createJSON({\n                    {"name", json::string(gameName)},\n                    {"type", json::integer(0)}\n                }) : "null"},\n                { "status", SleepyDiscord::json::string(statusString[status]) },\n                { "afk", SleepyDiscord::json::boolean(afk) }\n            })}\n        }));\n    }\n\n    void BaseDiscordClient::requestServerMembers(ServerMembersRequest request) {\n        auto data = json::toJSON(request);\n        std::string stringData = json::stringify(data);\n\n        std::string query;\n        query.reserve(14 + stringData.length());\n        query += "{\\"op\\":8,\\"d\\":";\n        query += stringData;\n        query += "}";\n\n        sendL(query);\n    }\n\n    void BaseDiscordClient::waitTilReady() {\n        while (!ready) sleep(1000);\n    }\n\n    void BaseDiscordClient::setShardID(int _shardID, int _shardCount) {\n        shardID = _shardID;\n        shardCount = _shardCount;\n    }\n\n    void BaseDiscordClient::getTheGateway() {\n#ifdef SLEEPY_USE_HARD_CODED_GATEWAY\n    #ifndef SLEEPY_HARD_CODED_GATEWAY\n        #define SLEEPY_HARD_CODED_GATEWAY "wss://gateway.discord.gg/?v=10"\n    #endif\n        theGateway = SLEEPY_HARD_CODED_GATEWAY; //This is needed for when session is disabled\n#else\n        Session session;\n        session.setUrl("https://discord.com/api/gateway");\n        Response a = session.request(Get);  //todo change this back to a post\n        if (!a.text.length()) { //error check\n            quit(false, true);\n            return setError(GATEWAY_FAILED);\n        }\n        if (!theGateway.empty())\n            theGateway.clear();\n        //getting the gateway\n        for (unsigned int position = 0, j = 0; ; ++position) {\n            if (a.text[position] == \'"\')\n                ++j;\n            else if (j == 3) {\n                const unsigned int start = position;\n                while (a.text[++position] != \'"\');\n                unsigned int size = position - start;\n                theGateway.reserve(32);\n                theGateway.append(a.text, start, size);\n                theGateway += "/?v=10";\n                break;\n            }\n        }\n#endif\n        if (useTrasportConnection == 1)\n            theGateway += "&compress=zlib-stream";\n    }\n\n    void BaseDiscordClient::sendIdentity() {\n        //{\n        //  "op":2,\n        //   "d":{\n        //      "token":my_token,\n        //      "properties":{\n        //          $os":"windows 10",\n        //          "$browser":"Sleepy_Discord",\n        //          "$device":"Sleepy_Discord",\n        //      },\n        //      "compress":false,\n        //      "large_threshold":250           /I don\'t know what this does\n        //  }\n        //}\n#if defined(_WIN32) || defined(_WIN64)\n        const char * os = "Windows";\n#elif defined(__APPLE__) || defined(__MACH__)\n        const char * os = "macOS";\n#elif defined(__linux__) || defined(linux) || defined(__linux)\n        const char * os = "Linux";\n#elif defined __FreeBSD__\n        const char * os = "FreeBSD";\n#elif defined(unix) || defined(__unix__) || defined(__unix)\n        const char * os = "Unix";\n#else\n        const char* os = "\\\\u00AF\\\\\\\\_(\\\\u30C4)_\\\\/\\\\u00AF";  //shrug I dunno\n#endif\n        std::string identity;\n        identity.reserve(272); //remember to change this number when editing identity\n        identity += \n        "{"\n            "\\"op\\":2,"\n            "\\"d\\":{"\n                "\\"token\\":\\""; identity += getToken(); identity += "\\","\n                "\\"properties\\":{"\n                    "\\"$os\\":\\""; identity += os; identity += "\\","\n                    "\\"$browser\\":\\"Sleepy_Discord\\","\n                    "\\"$device\\":\\"Sleepy_Discord\\""\n                "},"\n                "\\"compress\\":";\n                    identity += compressionHandler && useTrasportConnection != 1 ?\n                        "true" : "false"; identity += ",";\n        if (shardCount != 0 && shardID <= shardCount) {\n            identity +=\n                "\\"shard\\":[";\n            identity += \n                    std::to_string(shardID); identity += ",";\n            identity +=\n                    std::to_string(shardCount);\n            identity +=\n                "],";\n        }\n        if (hasIntents()) {\n            identity +=\n                "\\"intents\\":";\n            identity +=\n                std::to_string(intents);\n        identity +=\n                \',\';\n        }\n        identity +=\n                "\\"large_threshold\\":250"\n            "}"\n        "}";\n        sendL(identity);\n    }\n\n    void BaseDiscordClient::sendResume() {\n        std::string resume;\n        resume.reserve(208);\n        resume +=\n        "{"\n            "\\"op\\":6,"\n            "\\"d\\":{"\n                "\\"token\\":\\""; resume += getToken(); resume += "\\","\n                "\\"session_id\\":\\""; resume += sessionID; resume += "\\","\n                "\\"seq\\":"; resume += std::to_string(lastSReceived); resume +=\n            "}"\n        "}";\n        sendL(resume);\n        onResume();\n    }\n\n    void BaseDiscordClient::quit(bool isRestarting, bool isDisconnected) {\n        if (!isRestarting)\n            quiting = true;\n\n#ifdef SLEEPY_VOICE_ENABLED\n        //quit all voice connections\n        for (VoiceConnection& voiceConnection : voiceConnections)\n            voiceConnection.disconnect();\n#endif\n        if (heart.isValid()) heart.stop(); //stop heartbeating\n        stopReconnecting();\n        if (!isDisconnected) disconnectWebsocket(1000);\n        stopClient();\n        if (quiting) onQuit();\n    }\n\n    void BaseDiscordClient::restart() {\n        quit(true);\n        connect(theGateway, this, connection);\n        onRestart();\n    }\n\n    void BaseDiscordClient::reconnect(const unsigned int status) {\n        std::lock_guard<std::mutex> lock(connectionMutex);\n        if (isCurrentlyWaitingToReconnect == true)\n            return; //don\'t try to reconnect when waiting to reconnect\n        isCurrentlyWaitingToReconnect = true;\n\n        //before disconnecting, heartbeats need to stop or it\'ll crash\n        //and if it doesn\'t, it\'ll cause another reconnect\n        if (heart.isValid()) heart.stop();\n        //reset some heartbeat values, done so we don\'t spam discord\n        wasHeartbeatAcked = true;\n        lastHeartbeat = 0;\n        heartbeatInterval = 0;\n\n        disconnectWebsocket(status);\n        //it\'s recomemeded to get the gateway again after many reconnection tries\n        // but the chance of the gateway being different is very low so this line is\n        // commmented out as it seems to cause issues\n        //if (consecutiveReconnectsCount % 16 == 10 || theGateway.empty()) getTheGateway();\n        if (reconnectTimer.isValid())\n            reconnectTimer.stop();\n        reconnectTimer = schedule([this]() {\n            std::lock_guard<std::mutex> lock(connectionMutex);\n            isCurrentlyWaitingToReconnect = false;\n            connect(theGateway, this, connection);\n        }, getRetryDelay());\n        consecutiveReconnectsCount += 1;\n\n        if (useTrasportConnection == 1)\n            compressionHandler->resetStream();\n    }\n\n    void BaseDiscordClient::stopReconnecting() {\n        std::lock_guard<std::mutex> lock(connectionMutex);\n        isCurrentlyWaitingToReconnect = false;\n        consecutiveReconnectsCount = 0;\n        if (reconnectTimer.isValid())\n            reconnectTimer.stop();\n    }\n\n    void BaseDiscordClient::disconnectWebsocket(unsigned int code, const std::string reason) {\n        disconnect(code, reason, connection);\n        onDisconnect();\n    }\n\n    bool BaseDiscordClient::sendL(std::string message) {\n        if (nextHalfMin <= getEpochTimeMillisecond()) {\n            const unsigned int maxMessagesPerMin = 116;\n            const unsigned int halfMinMilliseconds = 30000;\n            const unsigned int maxMessagesPerHalfMin = maxMessagesPerMin / 2;\n\n            nextHalfMin += halfMinMilliseconds;\n            messagesRemaining = maxMessagesPerHalfMin;\n        }\n\n        if (--messagesRemaining < 0) {\n            messagesRemaining = 0;\n            setError(RATE_LIMITED);\n            return false;\n        }\n        send(message, connection);\n        return true;\n    }\n\n    constexpr unsigned int hash(const char* key, unsigned int i = 0) {\n        return !key[i] ? 0 : (hash(key, i + 1) * 31) + key[i] - \'A\';\n    }\n\n    void BaseDiscordClient::processMessage(const std::string &message) {\n        auto docPtr = std::make_shared<rapidjson::Document>();\n        rapidjson::Document& document = *docPtr;\n        document.Parse(message.c_str(), message.length());\n        //  { "op", "d", "s", "t" }\n        int op = document["op"].GetInt();\n        json::Value& d = document["d"];\n        switch (op) {\n        case DISPATCH:\n            lastSReceived = document["s"].GetInt();\n            postTask(\n                [this, docPtr, &d]() {\n                    rapidjson::Document& document = *docPtr;\n                    const json::Value& t = document["t"];\n                    handleDispatchEvent(t, d);\n                }\n            );\n        break;\n        case HELLO:\n            heartbeatInterval = d["heartbeat_interval"].GetInt();\n            heartbeat();\n            if (!ready) sendIdentity();\n            else sendResume();\n            break;\n        case RECONNECT:\n            reconnect();\n            break;\n        case INVALID_SESSION:\n            if (json::toBool(d) == true) {\n                schedule(&BaseDiscordClient::sendResume, 2500);\n            } else {\n                sessionID = "";\n                schedule(&BaseDiscordClient::sendIdentity, 2500);\n            }\n            break;\n        case HEARTBEAT_ACK:\n            wasHeartbeatAcked = true;\n            onHeartbeatAck();\n            break;\n        }\n    }\n\n    void BaseDiscordClient::handleDispatchEvent(const json::Value& t, json::Value& d) {\n        switch (hash(json::toStdString(t).c_str())) {\n        case hash("READY"): {\n            Ready readyData = d;\n            sessionID = readyData.sessionID;\n            bot = readyData.user.bot;\n            userID = readyData.user;\n            onReady(readyData);\n            ready = true;\n            stopReconnecting(); //Successfully connected\n        } break;\n        case hash("RESUMED"):\n            stopReconnecting(); //Successfully connected\n            onResumed();\n            break;\n        case hash("GUILD_CREATE"): {\n            Server server(d);\n            if (serverCache)\n                serverCache->insert(server);\n            onServer(server);\n        } break;\n        case hash("GUILD_DELETE"): {\n            UnavailableServer server(d);\n            if (serverCache) {\n                findServerInCache(server.ID, [=](ServerCache::iterator& found) {\n                    serverCache->erase(found);\n                    });\n            }\n            onDeleteServer(server);\n        } break;\n        case hash("GUILD_UPDATE"): {\n            Server server(d);\n            accessServerFromCache(server.ID, [server](Server& foundServer) {\n                json::mergeObj(foundServer, server);\n                });\n            onEditServer(server);\n        } break;\n        case hash("GUILD_BAN_ADD"): onBan(d["guild_id"], d["user"]); break;\n        case hash("GUILD_BAN_REMOVE"): onUnban(d["guild_id"], d["user"]); break;\n        case hash("GUILD_INTEGRATIONS_UPDATE"):                          break; //to do add this\n        case hash("GUILD_MEMBER_ADD"): {\n            Snowflake<Server> serverID = d["guild_id"];\n            ServerMember member(d);\n            appendObjectToCache(serverID, &Server::members, member);\n            onMember(serverID, member);\n        } break;\n        case hash("GUILD_MEMBER_REMOVE"): {\n            Snowflake<Server> serverID = d["guild_id"];\n            User user = d["user"];\n            eraseObjectFromCache(serverID, &Server::members, user.ID);\n            onRemoveMember(serverID, user);\n        } break;\n        case hash("GUILD_MEMBER_UPDATE"): {\n            Snowflake<Server> serverID = d["guild_id"];\n            User user = d["user"];\n            std::vector<Snowflake<Role>> roles = json::toArray<Snowflake<Role>>(d["roles"]);\n            auto nickValue = d.FindMember("nick");\n            std::string nick = nickValue != d.MemberEnd() && nickValue->value.IsString() ?\n                json::toStdString(nickValue->value) : "";\n            accessObjectFromCache(serverID, &Server::members, user.ID,\n                [user, roles, nick](Server&, ServerMember& member) {\n                    member.user = user;\n                    member.roles = roles;\n                    member.nick = nick;\n                }\n            );\n            onEditMember(serverID, user, roles, nick);\n        } break;\n        case hash("GUILD_MEMBERS_CHUNK"): onMemberChunk(d); break;\n        case hash("GUILD_ROLE_CREATE"): {\n            Snowflake<Server> serverID = d["guild_id"];\n            Role role = d["role"];\n            appendObjectToCache(serverID, &Server::roles, role);\n            onRole(serverID, role);\n        } break;\n        case hash("GUILD_ROLE_UPDATE"):\n        {\n            Snowflake<Server> serverID = d["guild_id"];\n            Role role = d["role"];\n            accessObjectFromCache(serverID, &Server::roles, role.ID,\n                [role](Server&, Role& foundRole) {\n                    foundRole = role;\n                }\n            );\n            onEditRole(serverID, role);\n        } break;\n        case hash("GUILD_ROLE_DELETE"): {\n            Snowflake<Server> serverID = d["guild_id"];\n            Snowflake<Role> roleID = d["role_id"];\n            eraseObjectFromCache(serverID, &Server::roles, roleID);\n            onDeleteRole(serverID, roleID);\n        } break;\n        case hash("GUILD_EMOJIS_UPDATE"): onEditEmojis(d["guild_id"], json::toArray<Emoji>(d["emojis"])); break;\n        case hash("CHANNEL_CREATE"): {\n            Channel channel = d;\n            appendObjectToCache(channel.serverID, &Server::channels, channel);\n            onChannel(d);\n        } break;\n        case hash("CHANNEL_UPDATE"): {\n            Channel channel = d;\n            accessObjectFromCache(channel.serverID, &Server::channels, channel.ID,\n                [channel](Server&, Channel& foundChannel) {\n                    foundChannel = channel;\n                }\n            );\n            onEditChannel(d);\n        } break;\n        case hash("CHANNEL_DELETE"): {\n            Channel channel = d;\n            eraseObjectFromCache(channel.serverID, &Server::channels, channel.ID);\n            onDeleteChannel(d);\n        } break;\n        case hash("CHANNEL_PINS_UPDATE"): {\n            const json::Value& lastPinTimeValue = d["last_pin_timestamp"];\n            onPinMessage(\n                d["channel_id"],\n                lastPinTimeValue.IsString() ?\n                json::toStdString(d["last_pin_timestamp"]) : ""\n            );\n        } break;\n        case hash("THREAD_CREATE"): onThread(d); break;\n        case hash("THREAD_UPDATE"): onThreadUpdate(d); break;\n        case hash("THREAD_DELETE"): onDeleteThread(d); break;\n        case hash("THREAD_LIST_SYNC"): onThreadListSync(d); break;\n        case hash("THREAD_MEMBER_UPDATE"): onEditThreadMember(d, d["guild_id"]); break;\n        case hash("THREAD_MEMBERS_UPDATE"): onEditThreadMembers(d); break;\n        case hash("PRESENCE_UPDATE"): onPresenceUpdate(d); break;\n        case hash("PRESENCES_REPLACE"):                          break;\n        case hash("USER_UPDATE"): onEditUser(d); break;\n        case hash("USER_SETTINGS_UPDATE"): onEditUserSettings(d); break;\n        case hash("VOICE_STATE_UPDATE"): {\n            VoiceState state(d);\n#ifdef SLEEPY_VOICE_ENABLED\n            if (!waitingVoiceContexts.empty()) {\n                auto iterator = find_if(waitingVoiceContexts.begin(), waitingVoiceContexts.end(),\n                    [&state](const VoiceContext* w) {\n                        return state.channelID == w->channelID && w->sessionID == "";\n                    });\n                if (iterator != waitingVoiceContexts.end()) {\n                    VoiceContext& context = **iterator;\n                    context.sessionID = state.sessionID;\n                    connectToVoiceIfReady(context);\n                }\n            }\n#endif\n            onEditVoiceState(state);\n        } break;\n        case hash("TYPING_START"): onTyping(d["channel_id"], d["user_id"], d["timestamp"].GetInt64() * 1000); break;\n        case hash("MESSAGE_CREATE"): onMessage(d); break;\n        case hash("MESSAGE_UPDATE"): onEditMessage(d); break;\n        case hash("MESSAGE_DELETE"): onDeleteMessages(d["channel_id"], { d["id"] }); break;\n        case hash("MESSAGE_DELETE_BULK"): onDeleteMessages(d["channel_id"], json::toArray<Snowflake<Message>>(d["ids"])); break;\n        case hash("VOICE_SERVER_UPDATE"): {\n            VoiceServerUpdate voiceServer(d);\n#ifdef SLEEPY_VOICE_ENABLED\n            if (!waitingVoiceContexts.empty()) {\n                auto iterator = find_if(waitingVoiceContexts.begin(), waitingVoiceContexts.end(),\n                    [&voiceServer](const VoiceContext* w) {\n                        return voiceServer.serverID == w->serverID && w->endpoint == "";\n                    });\n                if (iterator != waitingVoiceContexts.end()) {\n                    VoiceContext& context = **iterator;\n                    context.token = voiceServer.token;\n                    context.endpoint = voiceServer.endpoint;\n                    connectToVoiceIfReady(context);\n                }\n            }\n#endif\n            onEditVoiceServer(voiceServer);\n        } break;\n        case hash("MESSAGE_REACTION_ADD"): onReaction(d["user_id"], d["channel_id"], d["message_id"], d["emoji"]); break;\n        case hash("MESSAGE_REACTION_REMOVE"): onDeleteReaction(d["user_id"], d["channel_id"], d["message_id"], d["emoji"]); break;\n        case hash("MESSAGE_REACTION_REMOVE_ALL"): onDeleteAllReaction(d["guild_id"], d["channel_id"], d["message_id"]); break;\n        case hash("APPLICATION_COMMAND_CREATE"): onAppCommand(d); break;\n        case hash("APPLICATION_COMMAND_UPDATE"): onEditAppCommand(d); break;\n        case hash("APPLICATION_COMMAND_DELETE"): onDeleteAppCommand(d); break;\n        case hash("INTERACTION_CREATE"): onInteraction(d); break;\n        case hash("STAGE_INSTANCE_CREATE"): onStageInstance(d); break;\n        case hash("STAGE_INSTANCE_UPDATE"): onEditStageInstance(d); break;\n        case hash("STAGE_INSTANCE_DELETE"): onDeleteStageInstance(d); break;\n        default:\n            onUnknownEvent(json::toStdString(t), d);\n            break;\n        }\n        onDispatch(t, d);\n    }\n\n    void BaseDiscordClient::processMessage(const WebSocketMessage message) {\n        switch (message.opCode) {\n        case WebSocketMessage::OPCode::binary: {\n            if (!compressionHandler)\n                break;\n            compressionHandler->uncompress(message.payload);\n            \n            //when using transport connections, Discord ends streams the flush siginal\n            constexpr std::array<const char, 4> flushSiginal = { 0, 0, \'\\xFF\', \'\\xFF\'};\n            constexpr std::size_t siginalLength = flushSiginal.max_size();\n            bool endsWithFlushSiginal = false;\n            if (useTrasportConnection == 1 && siginalLength <= message.payload.length()) {\n                const auto compare = message.payload.compare(\n                    message.payload.length() - siginalLength, siginalLength,\n                    flushSiginal.data(), siginalLength);\n                endsWithFlushSiginal = compare == 0;\n            }\n\n            //trasportConnection doesn\'t stop the stream\n            bool streamEnded = useTrasportConnection != 1 && compressionHandler->streamEnded();\n\n            if (streamEnded || endsWithFlushSiginal) {\n                std::shared_ptr<std::string> uncompressed = std::make_shared<std::string>();\n                compressionHandler->getOutput(*uncompressed);\n                processMessage(*uncompressed);\n            }\n            break;\n        }\n        case WebSocketMessage::OPCode::text: {\n            processMessage(message.payload);\n            break;\n        }\n        default: break;\n        }\n    }\n\n    void BaseDiscordClient::processCloseCode(const int16_t code) {\n        setError(code);\n\n        switch (code) {\n        //Just reconnect\n        case 1006:\n        case UNKNOWN_ERROR:\n        case UNKNOWN_OPCODE:\n        case DECODE_ERROR:\n        case NOT_AUTHENTICATED:\n        case ALREADY_AUTHENTICATED:\n        case INVALID_SEQ:\n        case RATE_LIMITED:\n        case SESSION_TIMEOUT:\n        default:\n            break;\n\n        case 1000:\n            if (!isQuiting())\n                break;\n            //else fall through\n\n        //Might be Unrecoveralbe\n        //We may need to stop to prevent a restart loop.\n        case AUTHENTICATION_FAILED:\n        case INVALID_SHARD:\n        case SHARDING_REQUIRED:\n        case INVALID_INTENTS:\n        case DISALLOWED_INTENTS:\n            return quit(false, true);\n            break;\n\n        case 4900: //Sleepy Discord reconnect\n            //don\'t do another reconnect during a reconnect\n            return;\n        }\n        reconnect();\n    }\n\n    void BaseDiscordClient::heartbeat() {\n        if (heartbeatInterval <= 0 || isQuiting()) return; //sanity test\n        \n        //if time and timer are out of sync, trust time\n        time_t currentTime = getEpochTimeMillisecond();\n        time_t nextHeartbest;\n        if (currentTime < (nextHeartbest = lastHeartbeat + heartbeatInterval)) {\n            heart = schedule(&BaseDiscordClient::heartbeat, nextHeartbest - currentTime);\n            return;\n        }\n\n        if (!wasHeartbeatAcked) {\n            //dead connection\n            reconnect();\n            return; //don\'t heartbeat\n        }\n\n        sendHeartbeat();\n        lastHeartbeat = currentTime;\n\n        if (heart.isValid())\n            heart.stop();\n        heart = schedule(&BaseDiscordClient::heartbeat, heartbeatInterval);\n    }\n\n    //\n    //Voice\n    //\n\n#ifdef SLEEPY_VOICE_ENABLED\n\n    VoiceContext& BaseDiscordClient::createVoiceContext(Snowflake<Server> server, Snowflake<Channel> channel, BaseVoiceEventHandler * eventHandler) {\n        Snowflake<Server> serverTarget = server != "" ? server : getChannel(channel).cast().serverID;\n        voiceContexts.push_front({ serverTarget, channel, eventHandler });\n        waitingVoiceContexts.emplace_front(&voiceContexts.front());\n        return voiceContexts.front();\n    }\n\n    void BaseDiscordClient::connectToVoiceChannel(VoiceContext& voiceContext, VoiceMode settings) {\n        std::string voiceState;\n        /*The number 131 came from the number of letters in this string:\n          {"op": 4,"d" : {"guild_id": "18446744073709551615",\n          "channel_id" : "18446744073709551615","self_mute" : false,"self_deaf" : false}}\n          plus one\n        */\n        voiceState.reserve(131);  //remember to update this when making changes to voice status\n        voiceState +=\n            "{"\n                "\\"op\\": 4,"\n                "\\"d\\": {"\n                    "\\"guild_id\\": \\""; voiceState += voiceContext.serverID; voiceState += "\\","\n                    "\\"channel_id\\""": \\""; voiceState += voiceContext.channelID; voiceState += "\\","\n                    "\\"self_mute\\"" ": "; voiceState += settings & mute   ? "true" : "false"; voiceState += ","\n                    "\\"self_deaf\\"" ": "; voiceState += settings & deafen ? "true" : "false"; voiceState +=\n                "}"\n            "}";\n        sendL(voiceState);\n        /*Discord will response by sending a VOICE_STATE_UPDATE and a\n          VOICE_SERVER_UPDATE payload. Take a look at processMessage\n          function at case VOICE_STATE_UPDATE and voiceServerUpdate\n          */\n    }\n\n    VoiceContext& BaseDiscordClient::connectToVoiceChannel(Snowflake<Server> server, Snowflake<Channel> channel, VoiceMode settings) {\n        VoiceContext& target = createVoiceContext(server, channel);\n        connectToVoiceChannel(target, settings);\n        return target;\n    }\n\n    void BaseDiscordClient::connectToVoiceIfReady(VoiceContext& context) {\n        if (context.endpoint == "" || context.sessionID == "") //check that we are ready\n            return;\n\n        //remove the port numbers at the end of the endpoint string\n        std::string& givenEndpoint = context.endpoint;\n        givenEndpoint = givenEndpoint.substr(0, givenEndpoint.find(\':\'));\n\n        std::string endpoint = VoiceConnection::getWebSocketURI(givenEndpoint);\n\n        //Add a new connection to the list of connections\n        voiceConnections.emplace_front( this, context );\n        VoiceConnection& voiceConnection = voiceConnections.front();\n\n        connect(endpoint, &voiceConnection, voiceConnection.connection);\n\n        //remove from wait list\n        waitingVoiceContexts.remove_if(\n            [&context](VoiceContext* right) {\n                return &context == right;\n            }\n        );\n    }\n\n    void BaseDiscordClient::removeVoiceConnectionAndContext(VoiceConnection & connection) {\n        const VoiceContext& context = connection.getContext();\n        voiceConnections.remove_if(\n            [&connection](VoiceConnection& right) {\n                return connection == right;\n            }\n        );\n        voiceContexts.remove_if(\n            [&context](VoiceContext& right) {\n                return &context == &right;\n            }\n        );\n    }\n\n#endif\n\n    const time_t BaseDiscordClient::getEpochTimeMillisecond() {\n        auto ms = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n        return ms.time_since_epoch().count();\n    }\n\n    const double BaseDiscordClient::getEpochTimeSecond() {\n        auto seconds = std::chrono::time_point_cast<std::chrono::duration<double, std::ratio<1>>>(std::chrono::steady_clock::now());\n        return seconds.time_since_epoch().count();\n    }\n\n    const std::string BaseDiscordClient::getEditPositionString(const std::vector<std::pair<std::string, uint64_t>>& positions) {\n        std::vector<std::string> params(positions.size());\n        for (auto& value : positions) {\n            params.push_back(json::createJSON({\n                { "id", json::string(value.first) },\n                { "position", json::UInteger(value.second) }\n            }));\n        }\n        return json::createJSONArray(params);\n    }\n\n    Route::Route(const std::string route, const std::initializer_list<std::string>& _values)\n        : path(route), values(_values)\n    {\n        size_t targetSize = path.length();\n        for (std::string replacement : values)\n            targetSize += replacement.length();\n        _url.reserve(targetSize);\n\n        //In the future, use string view\n\n        size_t offset = 0;\n        for (std::string replacement : values) {\n            const size_t start = path.find(\'{\', offset);\n            const size_t end = path.find(\'}\', start);\n\n            //the +1 and -1 removes the { and }\n            const std::string identifier = path.substr(start + 1, end - start - 1);\n\n            auto foundParam = majorParameters.find(identifier);\n            if (foundParam != majorParameters.end()) {\n                foundParam->second = replacement;\n            }\n\n            _url += path.substr(offset, start - offset);\n            _url += replacement;\n            offset = end + 1; //the +1 removes the }\n        }\n        _url += path.substr(offset, path.length() - offset);\n\n    }\n\n    Route::Route(const char* route) : Route(route, {}) {}\n\n    const std::string Route::bucket(RequestMethod method) {\n        std::string target;\n        std::string methodString = std::to_string(method);\n        size_t targetLength = methodString.length();\n        for (auto param : majorParameters) {\n            targetLength += param.second.length();\n        }\n        targetLength = path.length();\n        target.reserve(targetLength);\n        target += methodString;\n        for (auto param : majorParameters) {\n            target += param.second;\n        }\n        target += path;\n        return target;\n    }\n}\n')),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Updated on 28 October 2023 at 21:20:08 UTC"))}h.isMDXComponent=!0}}]);