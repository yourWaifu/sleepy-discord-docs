"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[1098],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),i=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=i(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),d=i(n),m=r,y=d["".concat(o,".").concat(m)]||d[m]||u[m]||l;return n?a.createElement(y,s(s({ref:t},c),{},{components:n})):a.createElement(y,s({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=d;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:r,s[1]=p;for(var i=2;i<l;i++)s[i]=n[i];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8992:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return p},contentTitle:function(){return o},metadata:function(){return i},toc:function(){return c},default:function(){return d}});var a=n(3117),r=n(102),l=(n(7294),n(3905)),s=["components"],p={title:"include/sleepy_discord/json_wrapper.h"},o=void 0,i={unversionedId:"reference/Files/json__wrapper_8h",id:"reference/Files/json__wrapper_8h",title:"include/sleepy_discord/json_wrapper.h",description:"Namespaces",source:"@site/docs/reference/Files/json__wrapper_8h.md",sourceDirName:"reference/Files",slug:"/reference/Files/json__wrapper_8h",permalink:"/sleepy-discord/docs/reference/Files/json__wrapper_8h",tags:[],version:"current",frontMatter:{title:"include/sleepy_discord/json_wrapper.h"},sidebar:"Reference",previous:{title:"sleepy_discord/json_wrapper.cpp",permalink:"/sleepy-discord/docs/reference/Files/json__wrapper_8cpp"},next:{title:"sleepy_discord/message.cpp",permalink:"/sleepy-discord/docs/reference/Files/message_8cpp"}},c=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Classes",id:"classes",children:[],level:2},{value:"Types",id:"types",children:[],level:2},{value:"Functions",id:"functions",children:[],level:2},{value:"Defines",id:"defines",children:[],level:2},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum FieldType",id:"enum-fieldtype",children:[],level:3},{value:"enum FromJSONMode",id:"enum-fromjsonmode",children:[],level:3},{value:"typedef SizeType",id:"typedef-sizetype",children:[],level:3},{value:"using Value",id:"using-value",children:[],level:3},{value:"using Array",id:"using-array",children:[],level:3},{value:"using Values",id:"using-values",children:[],level:3},{value:"using JSONConverter",id:"using-jsonconverter",children:[],level:3}],level:2},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function createJSON",id:"function-createjson",children:[],level:3},{value:"function string",id:"function-string",children:[],level:3},{value:"function UInteger",id:"function-uinteger",children:[],level:3},{value:"function optionalUInteger",id:"function-optionaluinteger",children:[],level:3},{value:"function integer",id:"function-integer",children:[],level:3},{value:"function optionalInteger",id:"function-optionalinteger",children:[],level:3},{value:"function boolean",id:"function-boolean",children:[],level:3},{value:"function createJSONArray",id:"function-createjsonarray",children:[],level:3},{value:"function hasPushBack",id:"function-haspushback",children:[],level:3},{value:"function hasPushBack",id:"function-haspushback-1",children:[],level:3},{value:"function leaveAlone",id:"function-leavealone",children:[],level:3},{value:"function toString",id:"function-tostring",children:[],level:3},{value:"function toStdString",id:"function-tostdstring",children:[],level:3},{value:"function toStdStringView",id:"function-tostdstringview",children:[],level:3},{value:"function toInt",id:"function-toint",children:[],level:3},{value:"function toUint",id:"function-touint",children:[],level:3},{value:"function toInt64",id:"function-toint64",children:[],level:3},{value:"function toUint64",id:"function-touint64",children:[],level:3},{value:"function toDouble",id:"function-todouble",children:[],level:3},{value:"function toFloat",id:"function-tofloat",children:[],level:3},{value:"function toBool",id:"function-tobool",children:[],level:3},{value:"function toArray",id:"function-toarray",children:[],level:3},{value:"function toEnum",id:"function-toenum",children:[],level:3},{value:"function toJSON",id:"function-tojson",children:[],level:3},{value:"function pair",id:"function-pair",children:[],level:3},{value:"function pair",id:"function-pair-1",children:[],level:3},{value:"function pair",id:"function-pair-2",children:[],level:3},{value:"function pair",id:"function-pair-3",children:[],level:3},{value:"function castValue",id:"function-castvalue",children:[],level:3},{value:"function fromJSON",id:"function-fromjson",children:[],level:3}],level:2},{value:"Macro Documentation",id:"macro-documentation",children:[{value:"define RAPIDJSON_NO_SIZETYPEDEFINE",id:"define-rapidjson_no_sizetypedefine",children:[],level:3},{value:"define JSONStruct",id:"define-jsonstruct",children:[],level:3},{value:"define JSONStructStart",id:"define-jsonstructstart",children:[],level:3},{value:"define JSONStructEnd",id:"define-jsonstructend",children:[],level:3}],level:2},{value:"Source code",id:"source-code",children:[],level:2}],u={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,s);return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"namespaces"},"Namespaces"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord_1_1json"},"SleepyDiscord::json")))))),(0,l.kt)("h2",{id:"classes"},"Classes"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_get_default"},"SleepyDiscord::GetDefault")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_get_enum_base_type"},"SleepyDiscord::GetEnumBaseType")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_string_wrapper"},"SleepyDiscord::json::ArrayStringWrapper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_value_wrapper"},"SleepyDiscord::json::ArrayValueWrapper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_value_wrapper_3_01_type_00_01typename_01std_1_1enable__ic278f49c55d1ff83c8431dd68b94506f"},"SleepyDiscord::json::ArrayValueWrapper< Type, typename std::enable_if< std::is_constructible< Type, const Value >::value >::type >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_value_wrapper_3_01_type_00_01typename_01std_1_1enable__i57bef9183313cb1d101ea260a14b38a8"},"SleepyDiscord::json::ArrayValueWrapper< Type, typename std::enable_if< std::is_constructible< Type, Value >::value >::type >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_wrapper"},"SleepyDiscord::json::ArrayWrapper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_wrapper_3_01_value_00_01_base_01_4"},"SleepyDiscord::json::ArrayWrapper< Value, Base >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_empty_function"},"SleepyDiscord::json::EmptyFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_string_function"},"SleepyDiscord::json::IsStringFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_number_function"},"SleepyDiscord::json::IsNumberFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_bool_function"},"SleepyDiscord::json::IsBoolFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_array_function"},"SleepyDiscord::json::IsArrayFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_object_function"},"SleepyDiscord::json::IsObjectFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1has_serialize"},"SleepyDiscord::json::hasSerialize")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1has_is_type"},"SleepyDiscord::json::hasIsType")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper"},"SleepyDiscord::json::ClassTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01std_1_1string_01_4"},"SleepyDiscord::json::ClassTypeHelper< std::string >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01nonstd_1_1string__view_01_4"},"SleepyDiscord::json::ClassTypeHelper< nonstd::string_view >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01_value_01_4"},"SleepyDiscord::json::ClassTypeHelper< Value >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_primitive_type_function"},"SleepyDiscord::json::IsPrimitiveTypeFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_primitive_type_function_3_01bool_01_4"},"SleepyDiscord::json::IsPrimitiveTypeFunction< bool >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_primitive_type_helper"},"SleepyDiscord::json::PrimitiveTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01int_01_4"},"SleepyDiscord::json::ClassTypeHelper< int >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01uint32__t_01_4"},"SleepyDiscord::json::ClassTypeHelper< uint32_t >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01int64__t_01_4"},"SleepyDiscord::json::ClassTypeHelper< int64_t >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01uint64__t_01_4"},"SleepyDiscord::json::ClassTypeHelper< uint64_t >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01float_01_4"},"SleepyDiscord::json::ClassTypeHelper< float >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01double_01_4"},"SleepyDiscord::json::ClassTypeHelper< double >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01bool_01_4"},"SleepyDiscord::json::ClassTypeHelper< bool >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_base_enum_type_helper"},"SleepyDiscord::json::BaseEnumTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_enum_type_helper"},"SleepyDiscord::json::EnumTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_from_container_function"},"SleepyDiscord::json::FromContainerFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_to_container_function"},"SleepyDiscord::json::ToContainerFunction")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_container_type_helper"},"SleepyDiscord::json::ContainerTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_std_array_type_helper"},"SleepyDiscord::json::StdArrayTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_smart_ptr_type_helper"},"SleepyDiscord::json::SmartPtrTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_optional_type_helper"},"SleepyDiscord::json::OptionalTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_nullable_type_helper"},"SleepyDiscord::json::NullableTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_map_type_helper"},"SleepyDiscord::json::MapTypeHelper")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01std_1_1nullptr__t_01_4"},"SleepyDiscord::json::ClassTypeHelper< std::nullptr_t >")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_pair_impl"},"SleepyDiscord::json::PairImpl")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_complex_pair"},"SleepyDiscord::json::ComplexPair")))))),(0,l.kt)("h2",{id:"types"},"Types"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enum"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#enum-fieldtype"},"FieldType"))," { REQUIRIED_FIELD = 0, OPTIONAL_FIELD = 1 << 0, NULLABLE_FIELD = 1 << 1, OPTIONAL_NULLABLE_FIELD = OPTIONAL_FIELD")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enum"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#enum-fromjsonmode"},"FromJSONMode"))," { Default = 0, ReturnOnError = 1}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"typedef std::size_t"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#typedef-sizetype"},"SizeType")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"using rapidjson::Value"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#using-value"},"Value")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"using rapidjson::Value::ConstArray"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#using-array"},"Array")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"using Value"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#using-values"},"Values")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <class Return ",">"," ",(0,l.kt)("br",null),"using Return(*)(const Value &)"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#using-jsonconverter"},"JSONConverter")))))),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-createjson"},"createJSON")),"(std::initializer_list< std::pair< std::string, std::string >> json)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-string"},"string")),"(const std::string & s)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-uinteger"},"UInteger")),"(const uint64_t num)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-optionaluinteger"},"optionalUInteger")),"(const uint64_t num)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-integer"},"integer")),"(const int64_t num)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-optionalinteger"},"optionalInteger")),"(const int64_t num)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-boolean"},"boolean")),"(const bool boolean)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <class Type ",">"," ",(0,l.kt)("br",null),"const std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-createjsonarray"},"createJSONArray")),"(const std::vector< Type > source)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <typename T ",">"," ",(0,l.kt)("br",null),"constexpr auto"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-haspushback"},"hasPushBack")),"(int )")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <typename T ",">"," ",(0,l.kt)("br",null),"constexpr std::false_type"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-haspushback"},"hasPushBack")),"(long )")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const Value &"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-leavealone"},"leaveAlone")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const char *"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-tostring"},"toString")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"std::string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-tostdstring"},"toStdString")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nonstd::string_view"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-tostdstringview"},"toStdStringView")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-toint"},"toInt")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-touint"},"toUint")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int64_t"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-toint64"},"toInt64")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint64_t"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-touint64"},"toUint64")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-todouble"},"toDouble")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"float"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-tofloat"},"toFloat")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-tobool"},"toBool")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <class Type ,class Value ",">"," ",(0,l.kt)("br",null),"ArrayWrapper< Type, ArrayStringWrapper< Value > >"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-toarray"},"toArray")),"(Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <class Type ",">"," ",(0,l.kt)("br",null),"Type"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-toenum"},"toEnum")),"(const Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <class Object ",">"," ",(0,l.kt)("br",null),"Value"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-tojson"},"toJSON")),"(const Object & object, Value::AllocatorType & allocator)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <int defaultValue,template< class, int > class TypeHelper =PrimitiveTypeHelper,class Class ,class Type ",">"," ",(0,l.kt)("br",null),"constexpr PairImpl< Class, Type, TypeHelper< Type, defaultValue > >"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-pair"},"pair")),"(Type Class::",(0,l.kt)("em",{parentName:"td"}," member, const char ")," name, FieldType type)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <template< class > class TypeHelper =ClassTypeHelper,class Class ,class Type ",">"," ",(0,l.kt)("br",null),"constexpr PairImpl< Class, Type, TypeHelper< Type > >"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-pair"},"pair")),"(Type Class::",(0,l.kt)("em",{parentName:"td"}," member, const char ")," name, FieldType type)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <template< class, template< class... > class > class TypeHelper,template< class... > class TypeHelper2 =ClassTypeHelper,class Class ,class Type ",">"," ",(0,l.kt)("br",null),"constexpr PairImpl< Class, Type, TypeHelper< Type, TypeHelper2 > >"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-pair"},"pair")),"(Type Class::",(0,l.kt)("em",{parentName:"td"}," member, const char ")," name, FieldType type)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <template< class, class > class TypeHelper,template< class, template< class... > class > class TypeHelper2,template< class... > class TypeHelper3,class Class ,class Type ,class Type2 ",">"," ",(0,l.kt)("br",null),"constexpr PairImpl< Class, Type, TypeHelper< Type, TypeHelper2< Type2, TypeHelper3 > > >"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-pair"},"pair")),"(Type Class::",(0,l.kt)("em",{parentName:"td"}," member, const char ")," name, FieldType type)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <class Helper ,class ResultingObject ,class Value ",">"," ",(0,l.kt)("br",null),"bool"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-castvalue"},"castValue")),"(ResultingObject & result, Value & value)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"template <FromJSONMode mode =FromJSONMode::Default,class ResultingObject ,class Value ,size_t i =0",">"," ",(0,l.kt)("br",null),"std::enable_if< i==std::tuple_size< decltype(ResultingObject::JSONStruct)>::value, bool >::type"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#function-fromjson"},"fromJSON")),"(ResultingObject & , Value & )")))),(0,l.kt)("h2",{id:"defines"},"Defines"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#define-rapidjson_no_sizetypedefine"},"RAPIDJSON_NO_SIZETYPEDEFINE")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#define-jsonstruct"},"JSONStruct")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#define-jsonstructstart"},"JSONStructStart")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/json__wrapper_8h#define-jsonstructend"},"JSONStructEnd")))))),(0,l.kt)("h2",{id:"types-documentation"},"Types Documentation"),(0,l.kt)("h3",{id:"enum-fieldtype"},"enum FieldType"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"REQUIRIED_FIELD"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"OPTIONAL_FIELD"),(0,l.kt)("td",{parentName:"tr",align:null},"1 << 0"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NULLABLE_FIELD"),(0,l.kt)("td",{parentName:"tr",align:null},"1 << 1"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"OPTIONAL_NULLABLE_FIELD"),(0,l.kt)("td",{parentName:"tr",align:null},"OPTIONAL_FIELD"),(0,l.kt)("td",{parentName:"tr",align:null},"NULLABLE_FIELD")))),(0,l.kt)("h3",{id:"enum-fromjsonmode"},"enum FromJSONMode"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,l.kt)("th",{parentName:"tr",align:null},"Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Default"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ReturnOnError"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h3",{id:"typedef-sizetype"},"typedef SizeType"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"typedef std::size_t SizeType;\n")),(0,l.kt)("h3",{id:"using-value"},"using Value"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::json::Value = typedef rapidjson::Value;\n")),(0,l.kt)("h3",{id:"using-array"},"using Array"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::json::Array = typedef rapidjson::Value::ConstArray;\n")),(0,l.kt)("h3",{id:"using-values"},"using Values"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::json::Values = typedef Value;\n")),(0,l.kt)("h3",{id:"using-jsonconverter"},"using JSONConverter"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class Return >\nusing SleepyDiscord::json::JSONConverter = typedef Return(*)(const Value&);\n")),(0,l.kt)("h2",{id:"functions-documentation"},"Functions Documentation"),(0,l.kt)("h3",{id:"function-createjson"},"function createJSON"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::string createJSON(\n    std::initializer_list< std::pair< std::string, std::string >> json\n)\n")),(0,l.kt)("h3",{id:"function-string"},"function string"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::string string(\n    const std::string & s\n)\n")),(0,l.kt)("h3",{id:"function-uinteger"},"function UInteger"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::string UInteger(\n    const uint64_t num\n)\n")),(0,l.kt)("h3",{id:"function-optionaluinteger"},"function optionalUInteger"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::string optionalUInteger(\n    const uint64_t num\n)\n")),(0,l.kt)("h3",{id:"function-integer"},"function integer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::string integer(\n    const int64_t num\n)\n")),(0,l.kt)("h3",{id:"function-optionalinteger"},"function optionalInteger"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::string optionalInteger(\n    const int64_t num\n)\n")),(0,l.kt)("h3",{id:"function-boolean"},"function boolean"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::string boolean(\n    const bool boolean\n)\n")),(0,l.kt)("h3",{id:"function-createjsonarray"},"function createJSONArray"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class Type >\nconst std::string createJSONArray(\n    const std::vector< Type > source\n)\n")),(0,l.kt)("h3",{id:"function-haspushback"},"function hasPushBack"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename T >\nconstexpr auto hasPushBack(\n    int \n)\n")),(0,l.kt)("h3",{id:"function-haspushback-1"},"function hasPushBack"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename T >\nconstexpr std::false_type hasPushBack(\n    long \n)\n")),(0,l.kt)("h3",{id:"function-leavealone"},"function leaveAlone"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline const Value & leaveAlone(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-tostring"},"function toString"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline const char * toString(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-tostdstring"},"function toStdString"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline std::string toStdString(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-tostdstringview"},"function toStdStringView"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline nonstd::string_view toStdStringView(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-toint"},"function toInt"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline int toInt(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-touint"},"function toUint"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline unsigned int toUint(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-toint64"},"function toInt64"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline int64_t toInt64(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-touint64"},"function toUint64"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline uint64_t toUint64(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-todouble"},"function toDouble"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline double toDouble(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-tofloat"},"function toFloat"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline float toFloat(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-tobool"},"function toBool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"inline bool toBool(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-toarray"},"function toArray"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class Type ,\nclass Value >\ninline ArrayWrapper< Type, ArrayStringWrapper< Value > > toArray(\n    Value & value\n)\n")),(0,l.kt)("h3",{id:"function-toenum"},"function toEnum"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class Type >\ninline Type toEnum(\n    const Value & value\n)\n")),(0,l.kt)("h3",{id:"function-tojson"},"function toJSON"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class Object >\ninline Value toJSON(\n    const Object & object,\n    Value::AllocatorType & allocator\n)\n")),(0,l.kt)("h3",{id:"function-pair"},"function pair"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <int defaultValue,\ntemplate< class, int > class TypeHelper =PrimitiveTypeHelper,\nclass Class ,\nclass Type >\nconstexpr PairImpl< Class, Type, TypeHelper< Type, defaultValue > > pair(\n    Type Class::* member,\n    const char * name,\n    FieldType type\n)\n")),(0,l.kt)("h3",{id:"function-pair-1"},"function pair"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <template< class > class TypeHelper =ClassTypeHelper,\nclass Class ,\nclass Type >\nconstexpr PairImpl< Class, Type, TypeHelper< Type > > pair(\n    Type Class::* member,\n    const char * name,\n    FieldType type\n)\n")),(0,l.kt)("h3",{id:"function-pair-2"},"function pair"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <template< class, template< class... > class > class TypeHelper,\ntemplate< class... > class TypeHelper2 =ClassTypeHelper,\nclass Class ,\nclass Type >\nconstexpr PairImpl< Class, Type, TypeHelper< Type, TypeHelper2 > > pair(\n    Type Class::* member,\n    const char * name,\n    FieldType type\n)\n")),(0,l.kt)("h3",{id:"function-pair-3"},"function pair"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <template< class, class > class TypeHelper,\ntemplate< class, template< class... > class > class TypeHelper2,\ntemplate< class... > class TypeHelper3,\nclass Class ,\nclass Type ,\nclass Type2 >\nconstexpr PairImpl< Class, Type, TypeHelper< Type, TypeHelper2< Type2, TypeHelper3 > > > pair(\n    Type Class::* member,\n    const char * name,\n    FieldType type\n)\n")),(0,l.kt)("h3",{id:"function-castvalue"},"function castValue"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class Helper ,\nclass ResultingObject ,\nclass Value >\ninline bool castValue(\n    ResultingObject & result,\n    Value & value\n)\n")),(0,l.kt)("h3",{id:"function-fromjson"},"function fromJSON"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <FromJSONMode mode =FromJSONMode::Default,\nclass ResultingObject ,\nclass Value ,\nsize_t i =0>\ninline std::enable_if< i==std::tuple_size< decltype(ResultingObject::JSONStruct)>::value, bool >::type fromJSON(\n    ResultingObject & ,\n    Value & \n)\n")),(0,l.kt)("h2",{id:"macro-documentation"},"Macro Documentation"),(0,l.kt)("h3",{id:"define-rapidjson_no_sizetypedefine"},"define RAPIDJSON_NO_SIZETYPEDEFINE"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"#define RAPIDJSON_NO_SIZETYPEDEFINE \n")),(0,l.kt)("h3",{id:"define-jsonstruct"},"define JSONStruct"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"#define JSONStruct JSONStructure\n")),(0,l.kt)("h3",{id:"define-jsonstructstart"},"define JSONStructStart"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"#define JSONStructStart constexpr static auto JSONStruct =\n")),(0,l.kt)("h3",{id:"define-jsonstructend"},"define JSONStructEnd"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"#define JSONStructEnd \n")),(0,l.kt)("h2",{id:"source-code"},"Source code"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <list>\n#include <utility>\n#include <vector>\n#include <array>\n#include <tuple>\n#include <memory>\n#include <type_traits>\n//for errrors\n#include <iostream>\n#include "nonstd/optional.hpp"\n\n#define RAPIDJSON_NO_SIZETYPEDEFINE\ntypedef std::size_t SizeType;\n#include "rapidjson/document.h"\n#include "rapidjson/writer.h"\n#include "rapidjson/stringbuffer.h"\n#include "nonstd/string_view.hpp"\n//#include "json.h"\n\nnamespace SleepyDiscord {\n    //this is outside of the json namespace\n    //to stop us from hiting some compiler bugs\n    template<class Type>\n    struct GetDefault {\n        static inline const Type get() {\n            return static_cast<Type>(0);\n        }\n    };\n\n    template<class Type>\n    struct GetEnumBaseType {\n        using Value = int64_t;\n    };\n\n    namespace json {\n        //using Value = nonstd::string_view;\n        //using Values = std::vector<Value>;\n\n        using Value = rapidjson::Value;\n        using Array = rapidjson::Value::ConstArray;\n        using Values = Value;\n\n        //Values getArray(const Value& source);\n        //Values getValues(const char* source, std::initializer_list<const char *const> const &names);\n        //Value getValue(const char* source, const char * name);\n\n        const std::string createJSON(std::initializer_list<std::pair<std::string, std::string>> json);\n        const std::string string(const std::string& s);\n        const std::string UInteger(const uint64_t num);\n        const std::string optionalUInteger(const uint64_t num);\n        const std::string integer(const int64_t num);\n        const std::string optionalInteger(const int64_t num);\n        const std::string boolean(const bool boolean);\n\n        template<class Type>\n        const std::string createJSONArray(const std::vector<Type> source) {\n            if (source.empty())\n                return "";\n            std::string target;\n            target += \'[\';\n            for (std::string value : source) {\n                if (!value.empty()) {\n                    target += value;\n                    target += \',\';\n                }\n            }\n            char& back = target.back();\n            if (back == \',\') {\n                back = \']\';\n            } else {\n                target += \']\';\n            }\n            return target;\n        }\n\n        template <class Type>\n        struct ClassTypeHelper;\n\n        template<class Value = const json::Value>\n        struct ArrayStringWrapper {\n            Value& json;\n            ArrayStringWrapper(Value& json) : json(json) {}\n            inline Value& getDoc() const { return json; }\n            operator Value&() const { return getDoc(); }\n            template<class Callback>\n            const bool getDoc(const Callback& callback) const {\n                callback(json);\n                return true;\n            }\n        };\n\n        template<class Type, class Enable = void>\n        struct ArrayValueWrapper {\n            using value = const Value;\n            using type = ArrayStringWrapper<value>;\n        };\n\n        template<class Type>\n        struct ArrayValueWrapper<\n            Type, typename std::enable_if<std::is_constructible<Type, const Value>::value>::type\n        > {\n            using value = const Value;\n            using type = ArrayStringWrapper<value>;\n        };\n\n        template<class Type>\n        struct ArrayValueWrapper<\n            Type, typename std::enable_if<std::is_constructible<Type, Value>::value>::type\n        > {\n            using value = Value;\n            using type = ArrayStringWrapper<value>;\n        };\n\n        template <typename T>\n        constexpr auto hasPushBack(int)\n            -> decltype( std::declval<T>().push_back(*(std::declval<T>().begin())),\n                            std::true_type() );\n        \n        template <typename T>\n        constexpr std::false_type hasPushBack(long);\n\n        template<class TypeToConvertTo, class Base = typename ArrayValueWrapper<TypeToConvertTo>::type>\n        struct ArrayWrapper : public Base {\n            using base = Base;\n            using Base::Base;\n            using DocType = decltype(std::declval<Base>().getDoc());\n\n            template<class Container, class Value>\n            static inline Container get(Value& value, std::true_type) {\n                auto jsonArray = value.GetArray(); //can be ether const Array or Array, so we use auto\n                return Container(jsonArray.begin(), jsonArray.end());\n            }\n\n            template<class Container, class Value>\n            static inline Container get(Value&& value, std::false_type) {\n                DocType v = std::move(value);\n                return get<Container>(v, std::true_type{});\n            }\n\n            template<class Container, class Value>\n            static inline Container get(Value&& value) { //lvalue check\n                return get<Container>(value, std::is_lvalue_reference<Value&&>());\n            }\n\n            template<class Container>\n            Container get() {\n                return get<Container>(Base::getDoc());\n            }\n\n            template<template<class...> class Container, typename Type = TypeToConvertTo>\n            Container<Type> get() {\n                return get<Container<Type>>();\n            }\n\n            template<class Container>\n            bool get(Container& value) {\n                const auto getter = [&value](DocType& doc) {\n                    value = std::move(get<Container>(doc));\n                };\n                return Base::getDoc(getter);\n            }\n\n            template<template<class...> class Container, typename Type = TypeToConvertTo>\n            bool get(Container<Type>& value) {\n                return get<Container<Type>>(value);\n            }\n\n            inline std::vector<TypeToConvertTo> vector() { return get<std::vector>(); }\n            inline std::list  <TypeToConvertTo> list  () { return get<std::list>();   }\n\n            //c arrays\n            inline TypeToConvertTo* cArray() { return &vector()[0]; }\n\n            operator Values() { return Base::getArray(); }\n            operator std::vector<TypeToConvertTo>() { return vector(); }\n            operator std::list<TypeToConvertTo>() { return list(); }\n        };\n\n        template<class Return>\n        using JSONConverter = Return(*)(const Value&);\n\n        inline const Value& leaveAlone(const Value& value) {\n            return value;\n        }\n\n        inline const char* toString(const Value& value) {\n            return value.GetString();\n        }\n\n        inline std::string toStdString(const Value& value) {\n            return std::string(value.GetString(), value.GetStringLength());\n        }\n\n        inline nonstd::string_view toStdStringView(const Value& value) {\n            return nonstd::string_view(value.GetString(), value.GetStringLength());\n        }\n\n        inline int toInt(const Value& value) {\n            return value.GetInt();\n        }\n\n        inline unsigned int toUint(const Value& value) {\n            return value.GetUint();\n        }\n\n        inline int64_t toInt64(const Value& value) {\n            return value.GetInt64();\n        }\n\n        inline uint64_t toUint64(const Value& value) {\n            return value.GetUint64();\n        }\n\n        inline double toDouble(const Value& value) {\n            return value.GetDouble();\n        }\n\n        inline float toFloat(const Value& value) {\n            return value.GetFloat();\n        }\n\n        inline bool toBool(const Value& value) {\n            return value.GetBool();\n        }\n\n        template<class Type, class Value>\n        inline ArrayWrapper<Type, ArrayStringWrapper<Value>> toArray(Value& value) {\n            return ArrayWrapper<Type, ArrayStringWrapper<Value>>(value);\n        }\n\n        template<class Type>\n        inline Type toEnum(const Value& value) {\n            return static_cast<Type>(value.Get<typename GetEnumBaseType<Type>::Value>());\n        }\n\n        template<class Base>\n        struct ArrayWrapper<Value, Base> : public Base {\n            using Base::Base;\n            operator Values() {\n                return Base::getArray();\n            }\n        };\n\n        template <class Type>\n        struct EmptyFunction {\n            static inline bool empty(const Type& value) {\n                return value.empty();\n            }\n        };\n\n        struct IsStringFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsString();\n            }\n        };\n\n        struct IsNumberFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsNumber();\n            }\n        };\n\n        struct IsBoolFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsBool();\n            }\n        };\n\n        struct IsArrayFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsArray();\n            }\n        };\n\n        struct IsObjectFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsObject();\n            }\n        };\n\n        //ClassTypeHelper needs to be able to call toJSON so it\'s forward decleared\n        template<class Object>\n        inline Value toJSON(const Object& object, Value::AllocatorType& allocator);\n\n        //ClassTypeHelper needs to know if object has a serialize member\n        template<class Object>\n        struct hasSerialize {\n        private:\n            template<typename T>\n            static constexpr auto check(T*)\n            -> typename\n                std::is_same<\n                    decltype( std::declval<T>().serialize(\n                        std::declval<Value::AllocatorType&>()\n                    ) ),\n                    Value\n                >::type;\n            \n            template<typename>\n            static constexpr std::false_type check(...);\n        \n        public:\n            using type = decltype(check<Object>(0));\n            static constexpr bool value = type::value;\n        };\n\n        template<class Object>\n        struct hasIsType {\n        private:\n            template<typename T>\n            static constexpr auto check(T*)\n            -> typename\n                std::is_same<\n                    decltype( std::declval<T>().isType(\n                        std::declval<Value&>()\n                    ) ),\n                    bool\n                >::type;\n            \n            template<typename>\n            static constexpr std::false_type check(...);\n        \n        public:\n            using type = decltype(check<Object>(0));\n            static constexpr bool value = type::value;\n        };\n\n        template <class Type>\n        struct ClassTypeHelper : public EmptyFunction<Type> {\n            template<class Value>\n            static inline Type toType(Value& value) {\n                return value;\n            }\n\n            template<class T>\n            static inline typename std::enable_if<hasSerialize<T>::value, Value>::type\n            fromType(const T& value, Value::AllocatorType& allocator) {\n                return value.serialize(allocator);\n            }\n\n            template<class T>\n            static inline typename std::enable_if<hasSerialize<T>::value == false, Value>::type\n            fromType(const T& value, Value::AllocatorType& allocator) {\n                return toJSON(value, allocator);\n            }\n\n            template<class T = Type>\n            static inline typename std::enable_if<hasIsType<T>::value, bool>::type\n            isType(const Value& value) {\n                return Type::isType(value);\n            }\n\n            template<class T = Type>\n            static inline typename std::enable_if<!hasIsType<T>::value, bool>::type\n            isType(const Value& value) {\n                return value.IsObject();\n            }\n        };\n\n        template<>\n        struct ClassTypeHelper<std::string> :\n            public EmptyFunction<std::string>, public IsStringFunction\n        {\n            static inline std::string toType(const Value& value) {\n                return toStdString(value);\n            }\n            static inline Value fromType(const std::string& value) {\n                return Value(value.c_str(), value.length());\n            }\n            static inline Value fromType(const std::string& value, Value::AllocatorType&) {\n                return fromType(value);\n            }\n        };\n\n        template<>\n        struct ClassTypeHelper<nonstd::string_view> :\n            public EmptyFunction<nonstd::string_view>, public IsStringFunction\n        {\n            static inline nonstd::string_view toType(const Value& value) {\n                return toStdStringView(value);\n            }\n            static inline Value fromType(const nonstd::string_view& value) {\n                return Value(value.data(), value.length());\n            }\n            static inline Value fromType(const nonstd::string_view& value, Value::AllocatorType&) {\n                return fromType(value);\n            }\n        };\n\n        template<>\n        struct ClassTypeHelper<Value> {\n            static inline rapidjson::Type toType(const Value& value) {\n                //this doesn\'t really do anything\n                //we can\'t copy without allocator\n                //we can only have one return type\n                return value.GetType();\n            }\n            static inline Value& toType(Value& value) {\n                return value; // moves\n            }\n            static inline bool empty(const Value& value) {\n                return value.Empty();\n            }\n            static inline Value fromType(const Value& value, Value::AllocatorType& alloc) {\n                return Value{value, alloc}; //copys\n            }\n            static inline bool isType(const Value&) {\n                return true;\n            }\n        };\n\n        template<class PrimitiveType>\n        struct IsPrimitiveTypeFunction : IsNumberFunction {};\n\n        template<>\n        struct IsPrimitiveTypeFunction<bool> : IsBoolFunction {};\n\n        template <class PrimitiveType, int defaultValue = 0>\n        struct PrimitiveTypeHelper : public IsPrimitiveTypeFunction<PrimitiveType> {\n            static inline PrimitiveType toType(const Value& value) {\n                return value.Get<PrimitiveType>();\n            }\n            static inline bool empty(const PrimitiveType& value) {\n                return value == static_cast<PrimitiveType>(defaultValue);\n            }\n            static inline Value fromType(const PrimitiveType& value) {\n                return Value(value);\n            }\n            static inline Value fromType(const PrimitiveType& value, Value::AllocatorType& /*allocator*/) {\n                return fromType(value);\n            }\n        };\n\n        //for some reason, some compilers need this\n        //template <int defaultValue>\n        //struct PrimitiveTypeHelper<long int, defaultValue> : public PrimitiveTypeHelper<long long, defaultValue> {};\n\n        template<> struct ClassTypeHelper<int     > : public PrimitiveTypeHelper<int     > {};\n        template<> struct ClassTypeHelper<uint32_t> : public PrimitiveTypeHelper<uint32_t> {};\n        template<> struct ClassTypeHelper<int64_t > : public PrimitiveTypeHelper<int64_t > {};\n        template<> struct ClassTypeHelper<uint64_t> : public PrimitiveTypeHelper<uint64_t> {};\n        template<> struct ClassTypeHelper<float   > : public PrimitiveTypeHelper<float   > {};\n        template<> struct ClassTypeHelper<double  > : public PrimitiveTypeHelper<double  > {};\n        template<> struct ClassTypeHelper<bool    > : public PrimitiveTypeHelper<bool    > {};\n\n        template<class Type, class GetDefault, class BaseType>\n        struct BaseEnumTypeHelper {\n            static inline Type toType(const Value& value) {\n                return toEnum<Type>(value);\n            }\n            static inline Value fromType(const Type& value) {\n                return Value(static_cast<BaseType>(value));\n            }\n            static inline Value fromType(const Type& value, Value::AllocatorType&) {\n                return fromType(value);\n            }\n            static inline bool empty(const Type& value) {\n                return value == GetDefault::get();\n            }\n            static inline bool isType(const Value& value) {\n                return ClassTypeHelper<BaseType>::isType(value);\n            }\n        };\n\n        template<class Type>\n        struct EnumTypeHelper : public\n            BaseEnumTypeHelper<Type, GetDefault<Type>, typename GetEnumBaseType<Type>::Value> {};\n\n        template<class Container, template<class...> class TypeHelper>\n        struct FromContainerFunction {\n            static inline Value fromType(const Container& values, Value::AllocatorType& allocator) {\n                Value arr(rapidjson::kArrayType);\n                arr.Reserve(values.size(), allocator);\n                for (const typename Container::value_type& value : values)\n                    arr.PushBack(TypeHelper<typename Container::value_type>::fromType(value, allocator), allocator);\n                return arr;\n            } \n        };\n\n        template<class Container, template<class...> class TypeHelper>\n        struct ToContainerFunction {\n            template<class Value>\n            static inline Container toType(Value& value) {\n                auto jsonArray = value.GetArray();\n                using Helper = TypeHelper<typename Container::value_type>;\n                Container result;\n                std::transform(jsonArray.begin(), jsonArray.end(),\n                    std::back_inserter(result),\n                    [](Value& value){ \n                        return Helper::toType(value);\n                    }\n                );\n                return result;\n            }\n        };\n\n        template<class Container, template<class...> class TypeHelper>\n        struct ContainerTypeHelper :\n            public ToContainerFunction<Container, TypeHelper>,\n            public EmptyFunction<Container>,\n            public FromContainerFunction<Container, TypeHelper>,\n            public IsArrayFunction {};\n\n        template<class StdArray, template<class...> class TypeHelper>\n        struct StdArrayTypeHelper :\n            public EmptyFunction<StdArray>,\n            public FromContainerFunction<StdArray, TypeHelper>,\n            public IsArrayFunction\n        {\n            static inline StdArray toType(const Value& value) {\n                ArrayWrapper<typename StdArray::value_type> arrayWrapper(value);\n                std::array<typename StdArray::value_type, std::tuple_size<StdArray>::value> arr;\n                Array jsonArray = arrayWrapper.getDoc().template Get<Array>();\n                Value::ConstValueIterator iterator = jsonArray.Begin();\n                for (typename StdArray::value_type& v : arr) {\n                    if (iterator == jsonArray.End())\n                        break;\n                    v = TypeHelper<typename StdArray::value_type>::toType(*iterator);\n                    ++iterator;\n                }\n                return arr;\n                //return toArray<typename StdArray::value_type, std::tuple_size<StdArray>::value>(value);\n            }\n        };\n\n        template<class SmartPtr, template<class...> class TypeHelper>\n        struct SmartPtrTypeHelper {\n            template<class Value>\n            static inline SmartPtr toType(Value& value) {\n                return SmartPtr{new typename SmartPtr::element_type{\n                    //copy object to pointer\n                    TypeHelper<typename SmartPtr::element_type>::toType(value)\n                }};\n            }\n            static inline Value fromType(const SmartPtr& value, Value::AllocatorType& allocator) {\n                return TypeHelper<typename SmartPtr::element_type>::fromType(*value, allocator);\n            }\n            static inline bool empty(const SmartPtr& value) {\n                return value == nullptr;\n            }\n            static inline bool isType(const Value& value) {\n                return TypeHelper<typename SmartPtr::element_type>::isType(value);\n            }\n        };\n\n        //almost the same as SmartPtr\n        //maybe find a way to marge the two\n        template<class Optional, template<class...> class TypeHelper>\n        struct OptionalTypeHelper {\n            template<class Value>\n            static inline Optional toType(Value& value) {\n                return Optional{ TypeHelper<typename Optional::value_type>::toType(value) };\n            }\n            static inline Value fromType(const Optional& value, Value::AllocatorType& allocator) {\n                return TypeHelper<typename Optional::value_type>::fromType(*value, allocator);\n            }\n            static inline bool empty(const Optional& value) {\n                return !value.has_value();\n            }\n            static inline bool isType(const Value& value) {\n                 return TypeHelper<typename Optional::value_type>::isType(value);\n            }\n        };\n\n        template<class Nullable, template<class...> class TypeHelper>\n        struct NullableTypeHelper {\n            static inline Nullable toType(const Value& value) {\n                if (value.IsNull()) {\n                    return Nullable{ tl::nullopt };\n                } else {\n                    return Nullable{ TypeHelper<typename Nullable::value_type>::toType(value) };\n                }\n            }\n            static inline Value fromType(const Nullable& value, Value::AllocatorType& allocator) {\n                if (value) {\n                    return Value{ rapidjson::kNullType };\n                } else {\n                    return TypeHelper<typename Nullable::value_type>::fromType(*value, allocator);\n                }\n            }\n            static inline bool empty(const Nullable& value) {\n                return !value.has_value();\n            }\n            static inline bool isType(const Value& value) {\n                return value.IsNull() || TypeHelper<typename Nullable::value_type>::isType(value);\n            }\n        };\n\n        template<class Map, template<class...> class TypeHelper>\n        struct MapTypeHelper : public EmptyFunction<Map>, public IsObjectFunction {\n            template<class Value>\n            static inline Map toType(Value& value) {\n                Map target;\n                for (auto& member : value.GetObject()) {\n                    target.emplace(std::make_pair(\n                        toStdString(member.name),\n                        TypeHelper<typename Map::mapped_type>::toType(member.value)));\n                }\n                return target;\n            }\n            // serialize map but remember that the order depends on the type of map used\n            static inline Value fromType(const Map& value, Value::AllocatorType& allocator) {\n                Value target;\n                for (auto& member : value) {\n                    const std::string& name = static_cast<const std::string&>(member.first);\n                    target.AddMember(\n                        Value::StringRefType(name.c_str(), name.length()),\n                        TypeHelper<typename Map::mapped_type>::fromType(member.second, allocator),\n                        allocator);\n                }\n                return target;\n            }\n        };\n\n        template<>\n        struct ClassTypeHelper<std::nullptr_t> {\n            template<class Value>\n            static inline std::nullptr_t toType(Value& value) {\n                return nullptr;\n            }\n            static inline bool empty(const Value& value) {\n                return true;\n            }\n            static inline Value fromType(const Value& value, Value::AllocatorType& alloc) {\n                return Value{ rapidjson::kNullType };\n            }\n            static inline bool isType(const Value& value) {\n                return value.IsNull();\n            }\n        };\n\n        enum FieldType {\n            REQUIRIED_FIELD = 0,\n            OPTIONAL_FIELD  = 1 << 0,\n            NULLABLE_FIELD  = 1 << 1,\n            OPTIONAL_NULLABLE_FIELD = OPTIONAL_FIELD | NULLABLE_FIELD\n        };\n\n        template <class Class, class Type, class TypeHelper>\n        struct PairImpl {\n            using T = Type;\n            using Helper = TypeHelper;\n            Type Class::*member;\n            const char* name;\n            const FieldType type;\n        };\n\n        template <int defaultValue, template<class, int> class TypeHelper = PrimitiveTypeHelper, class Class, class Type>\n        constexpr PairImpl<Class, Type, TypeHelper<Type, defaultValue>> pair(Type Class::*member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, TypeHelper<Type, defaultValue>>{member, name, type};\n        }\n\n        template <template<class> class TypeHelper = ClassTypeHelper, class Class, class Type>\n        constexpr PairImpl<Class, Type, TypeHelper<Type>> pair(Type Class::*member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, TypeHelper<Type>>{member, name, type};\n        }\n\n        template <template<class, template<class...> class> class TypeHelper, template<class...> class TypeHelper2 = ClassTypeHelper, class Class, class Type>\n        constexpr PairImpl<Class, Type, TypeHelper<Type, TypeHelper2>> pair(Type Class::*member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, TypeHelper<Type, TypeHelper2>>{member, name, type};\n        }\n\n        template <template<class, template<class...> class> class TypeHelper, template<class, template<class...> class> class TypeHelper2, template<class...> class TypeHelper3 = ClassTypeHelper>\n        struct ComplexPair {\n            template<class Type>\n            using ComplexTypeHelper = TypeHelper2<Type, TypeHelper3>;\n\n            template<class Class, class Type>\n            static constexpr PairImpl<Class, Type, TypeHelper<Type, ComplexTypeHelper>> pair(Type Class::* member, const char* name, FieldType type) {\n                return PairImpl<Class, Type, TypeHelper<Type, ComplexTypeHelper>>{member, name, type};\n            }\n        };\n\n        template <template<class, class> class TypeHelper, template<class, template<class...> class> class TypeHelper2, template<class...> class TypeHelper3, class Class, class Type, class Type2>\n        constexpr PairImpl<Class, Type, TypeHelper<Type, TypeHelper2<Type2, TypeHelper3>>> pair(Type Class::* member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, TypeHelper<Type, TypeHelper2<Type2, TypeHelper3>>>{member, name, type};\n        }\n\n        //There needs to be a workaround for Visual C++ and clang for this to compile. However, this workaround relys on c++14.\n#if __cpp_return_type_deduction\n#define JSONStruct getJSONStructure()\n#define JSONStructStart constexpr static auto JSONStruct { return\n#define JSONStructEnd }\n#else\n#define JSONStruct JSONStructure\n#define JSONStructStart constexpr static auto JSONStruct =\n#define JSONStructEnd\n#endif\n\n        enum class FromJSONMode {\n            Default = 0,\n            ReturnOnError = 1\n        };\n\n        template<class Helper, class ResultingObject, class Value>\n        inline bool castValue(ResultingObject& result, Value& value) {\n            if (Helper::isType(value))\n                result = Helper::toType(value);\n            else\n                return false;\n            return true;\n        }\n\n        template<FromJSONMode mode = FromJSONMode::Default, class ResultingObject, class Value, size_t i = 0>\n        inline typename std::enable_if<i == std::tuple_size<decltype(ResultingObject::JSONStruct)>::value, bool>::type\n            fromJSON(ResultingObject&, Value&)\n        {\n            return true;\n        }\n\n        template<FromJSONMode mode = FromJSONMode::Default, class ResultingObject, class Value, size_t i = 0>\n        inline typename std::enable_if<i < std::tuple_size<decltype(ResultingObject::JSONStruct)>::value, bool>::type\n            fromJSON(ResultingObject& object, Value& value)\n        {\n            constexpr auto field = std::get<i>(ResultingObject::JSONStruct);\n            using Helper = typename decltype(field)::Helper;\n            auto iterator = value.FindMember(field.name);\n            if (iterator != value.MemberEnd()) {\n                if (castValue<Helper>(object.*(field.member), iterator->value)) {\n                    //success\n                } else if (field.type != REQUIRIED_FIELD && iterator->value.IsNull()) {\n                    //ignore\n                } else /*error*/ if (mode == FromJSONMode::ReturnOnError) {\n                    return false;\n                }\n            } else if (field.type == REQUIRIED_FIELD) {\n                //error\n                std::cout << \n                "JSON Parse Error: "\n                "variable #" << i << ": \\"" << field.name << "\\" not found. "\n                "Please look at call stack from your debugger for more details.";\n                if (mode == FromJSONMode::ReturnOnError)\n                    return false;\n            }\n            return fromJSON<mode, ResultingObject, Value, i + 1>(object, value);\n        }\n\n        template<class ResultingObject, class Value>\n        inline ResultingObject fromJSON(Value& value) {\n            ResultingObject object;\n            fromJSON(object, value);\n            return object;\n        }\n\n        template<class ResultingObject>\n        inline rapidjson::ParseResult fromJSON(ResultingObject& obj, const nonstd::string_view& json) {\n            rapidjson::Document doc;\n            rapidjson::ParseResult isOK = doc.Parse(json.data(), json.length());\n            if (isOK)\n                obj = ResultingObject{doc};\n            return isOK;\n        }\n\n        inline rapidjson::Document parse(const nonstd::string_view& json) {\n            rapidjson::Document doc;\n            doc.Parse(json.data(), json.length());\n            return doc;\n        }\n\n        template<class ResultingObject>\n        inline ResultingObject fromJSON(const nonstd::string_view& json) {\n            rapidjson::Document doc = parse(json);\n            //note: some objects have different value consturctors\n            //so we need to call the Object\'s value constructor\n            return ResultingObject(doc);\n        }\n\n        constexpr std::size_t stringLength(const char*const& string, std::size_t i = 0) {\n            return string[i] == \'\\0\' ? i : stringLength(string, i + 1);\n        }\n\n        template<class SourceObject, size_t i = 0>\n        inline typename std::enable_if<i == std::tuple_size<decltype(SourceObject::JSONStruct)>::value, void>::type\n            toJSON(const SourceObject& /*object*/, Value& /*value*/, Value::AllocatorType& /*allocator*/) {\n        }\n\n        template<class SourceObject, size_t i = 0>\n        inline typename std::enable_if < i < std::tuple_size<decltype(SourceObject::JSONStruct)>::value, void>::type\n            toJSON(const SourceObject& object, Value& value, Value::AllocatorType& allocator) {\n            constexpr auto field = std::get<i>(SourceObject::JSONStruct);\n            using Helper = typename decltype(field)::Helper;\n            //value[field.name] = object.*(field.member);\n            if (!(field.type & OPTIONAL_NULLABLE_FIELD) || !Helper::empty(object.*(field.member))) {\n                constexpr std::size_t nameLength = stringLength(field.name);\n                value.AddMember(\n                    Value::StringRefType(field.name, nameLength),\n                    Helper::fromType(object.*(field.member), allocator),\n                    allocator\n                );\n            }\n            toJSON<SourceObject, i + 1>(object, value, allocator);\n        }\n\n        template<class Object>\n        inline Value toJSON(const Object& object, Value::AllocatorType& allocator) {\n            Value obj(rapidjson::kObjectType);\n            toJSON(object, obj, allocator);\n            return obj;\n        }\n\n        template<class Object>\n        inline rapidjson::Document toJSON(const Object& object) {\n            rapidjson::Document doc;\n            doc.SetObject();\n            toJSON(object, doc, doc.GetAllocator());\n            return doc;\n        }\n\n        inline std::string stringify(const Value& value) {\n            rapidjson::StringBuffer buffer;\n            rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);\n            value.Accept(writer);\n            return std::string(buffer.GetString(), buffer.GetSize());\n        }\n\n        template<class Object>\n        inline std::string stringifyObj(const Object& object) {\n            rapidjson::MemoryPoolAllocator<> allocator;\n            return stringify(toJSON(object, allocator));\n        }\n\n        template<class Object, size_t i = 0>\n        inline typename std::enable_if<i == std::tuple_size<decltype(Object::JSONStruct)>::value, void>::type\n            mergeObj(Object& object, const Object& objectChanges) {\n        }\n\n        template<class Object, size_t i = 0>\n        inline typename std::enable_if < i < std::tuple_size<decltype(Object::JSONStruct)>::value, void>::type\n            mergeObj(Object& object, const Object& objectChanges) {\n            constexpr auto field = std::get<i>(Object::JSONStruct);\n            using Helper = typename decltype(field)::Helper;\n            if (!Helper::empty(objectChanges.*(field.member))) {\n                object.*(field.member) = objectChanges.*(field.member);\n            }\n            mergeObj<Object, i + 1>(object, objectChanges);\n        }\n\n        inline json::Value copy(const json::Value& value) {\n            rapidjson::Document doc;\n            return std::move(doc.CopyFrom(value, doc.GetAllocator()));\n        }\n\n        //json optional and null emulation\n        struct UndefinedType {};\n\n        template<class Type>\n        struct Maybe {\n            using FlagType = bool;\n            static constexpr FlagType undefined = 0;\n            static constexpr FlagType defined = 1;\n\n            using ValueType = Type;\n            using element_type = Type;\n            using Container = std::shared_ptr<Type>;\n            using weak_ptr = typename Container::weak_ptr;\n\n            const bool isUndefined() const {\n                return ( flags & defined ) == undefined;\n            }\n            const bool isDefined() const {\n                return !isUndefined();\n            }\n            const bool isAvaiable() const {\n                return isDefined() && static_cast<bool>(value);\n            }\n            const bool isNull() const {\n                return isDefined() && !static_cast<bool>(value);\n            }\n             \n            Type copy(Type& defaultValue) const {\n                return isDefined() ? static_cast<bool>(value) ? *get() : defaultValue : defaultValue;\n            }\n            \n            void copyTo(Type& dest) const {\n                if (isAvaiable())\n                    dest = *get();\n            }\n\n            constexpr Maybe() = default;\n            constexpr Maybe(std::nullptr_t) noexcept : value(std::nullptr_t{}), flags(defined) {};\n            Maybe& operator=(std::nullptr_t) noexcept {\n                value = std::nullptr_t{};\n                flags |= defined;\n            }\n            constexpr Maybe(UndefinedType) {};\n            template<class TypeY>\n            explicit Maybe(TypeY* ptr) noexcept : value(ptr), flags(defined) {}\n            template<class TypeY, class Deleter>\n            Maybe(Type* ptr, Deleter deleter) noexcept :\n                value(ptr, deleter), flags(defined) {}\n            template<class TypeY, class Deleter, class Alloc>\n            Maybe(Type* ptr, Deleter deleter, Alloc allocator) noexcept :\n                value(ptr, deleter, allocator), flags(defined) {}\n            template<class Deleter>\n            Maybe(std::nullptr_t, Deleter deleter) : value(nullptr, deleter), flags(defined) {}\n            template<class Deleter, class Alloc>\n            Maybe(std::nullptr_t, Deleter deleter, Alloc allocator) noexcept :\n                value(nullptr, deleter, allocator), flags(defined) {}\n            template<class Deleter>\n            Maybe(UndefinedType, Deleter deleter) : value(nullptr, deleter) {}\n            template<class Deleter, class Alloc>\n            Maybe(UndefinedType, Deleter deleter, Alloc allocator) noexcept :\n                value(nullptr, deleter, allocator) {}\n            template<class Type2>\n            Maybe(const Maybe<Type2>& right, ValueType* pointer) noexcept :\n                value(right.value, pointer), flags(defined) {}\n            template<class Type2>\n            Maybe(const Maybe<Type2>&& right, ValueType* pointer) noexcept :\n                value(std::move(right.value), pointer), flags(defined) {}\n            Maybe(const Maybe& other) noexcept : value(other), flags(other.flags) {}\n            explicit Maybe(Container&& right) noexcept :\n                value(std::move(right)), flags(defined) {}\n            Maybe(Maybe&& right) noexcept :\n                value(std::move(right.value)), flags(right.flags) {}\n            template<class Type2>\n            Maybe(Maybe<Type2>&& right) noexcept :\n                value(std::move(right.value)), flags(right.value) {}\n            template<class Type2>\n            explicit Maybe(std::shared_ptr<Type2>&& right) noexcept :\n                value(std::move(right)), flags(defined) {}\n            template<class Type2>\n            explicit Maybe(const weak_ptr& other) :\n                value(other), flags(defined) {}\n            template<class Type2, class Deleter>\n            Maybe(std::unique_ptr<Type2, Deleter>&& other) :\n                value(std::move(other)), flags(defined) {}\n            \n\n            Maybe& operator=(const Maybe& right) noexcept {\n                Maybe(right).swap(*this);\n                return *this;\n            }\n\n            template<class Type2>\n            Maybe& operator=(const Maybe<Type2>& right) noexcept {\n                Maybe(right).swap(*this);\n                return *this;\n            }\n\n            Maybe& operator=(Maybe&& right) noexcept {\n                Maybe(std::move(right)).swap(*this);\n                return *this;\n            }\n\n            template<class Type2>\n            Maybe& operator=(Maybe<Type2>&& right) noexcept {\n                Maybe(std::move(right)).swap(*this);\n                return *this;\n            }\n\n            template<class TypeX, class Deleter>\n            Maybe& operator=(std::unique_ptr<TypeX, Deleter>&& right) {\n                Maybe(std::move(right)).swap(*this);\n                return *this;\n            }\n\n            Maybe& operator=(const Container& right) noexcept {\n                Maybe(right).swap(*this);\n                return *this;\n            }\n\n            Maybe& operator=(Container&& right) noexcept {\n                Maybe(std::move(right)).swap(*this);\n                return *this;\n            }\n\n            void swap(Maybe& right) noexcept {\n                value.swap(right.value);\n                std::swap(flags, right.flags);\n            }\n\n            ValueType& operator*() const noexcept {\n                return *value;\n            }\n\n            ValueType* operator->() const noexcept {\n                return value.operator->();\n            }\n\n            ValueType* get() const noexcept {\n                return value.get();\n            }\n\n            explicit operator bool() const noexcept {\n                return isAvaiable();\n            }\n\n            bool empty() const noexcept {\n                return isAvaiable();\n            }\n\n            ValueType* release() noexcept {\n                flags = undefined;\n                return value.release();\n            }\n\n            void reset() noexcept {\n                value.reset();\n            }\n\n            template<class TypeX>\n            void reset(ValueType* ptr) noexcept {\n                value.reset(ptr);\n            }\n\n            template<class TypeX, class Deleter>\n            void reset(ValueType* ptr, Deleter deleter) noexcept {\n                value.reset(ptr, deleter);\n            }\n\n            template<class TypeX, class Deleter, class Alloc>\n            void reset(ValueType* ptr, Deleter deleter, Alloc allocator) noexcept {\n                value.reset(ptr, deleter, allocator);\n            }\n\n            long use_count() const noexcept {\n                return value.use_count();\n            }\n\n            void setToUndefined() noexcept {\n                reset();\n                flags = undefined;\n            }\n\n            Container& getSmartPtr() const noexcept {\n                return value;\n            }\n\n        private:\n            Container value;\n            FlagType flags = undefined;\n        };\n\n        template<class MaybeType, template<class...> class TypeHelper>\n        struct MaybeTypeHelper : public EmptyFunction<MaybeType> {\n            static inline MaybeType toType(const Value& value) {\n                return TypeHelper<typename MaybeType::element_type>::toType(value);\n            }\n            static inline Value fromType(const MaybeType& value, Value::AllocatorType& allocator) {\n                return TypeHelper<typename MaybeType::element_type>::fromType(*value, allocator);\n            }\n        };\n\n        template <template<class...> class TypeHelper2 = ClassTypeHelper, class Class, class Type,\n            typename std::enable_if<\n                std::is_same<\n                    Type, Maybe<typename Type::ValueType>\n                >::value\n            >::type = true\n        >\n        constexpr PairImpl<Class, Type, MaybeTypeHelper<Type, TypeHelper2>> pair(Type Class::*member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, MaybeTypeHelper<Type, TypeHelper2>>{member, name, type};\n        }       \n    }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Updated on 28 October 2023 at 21:20:08 UTC"))}d.isMDXComponent=!0}}]);