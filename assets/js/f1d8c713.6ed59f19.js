"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[9135],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var s=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,s,a=function(e,n){if(null==e)return{};var t,s,a={},r=Object.keys(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=s.createContext({}),d=function(e){var n=s.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=d(e.components);return s.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return s.createElement(s.Fragment,{},n)}},u=s.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=d(t),m=a,g=u["".concat(l,".").concat(m)]||u[m]||p[m]||r;return t?s.createElement(g,o(o({ref:n},c),{},{components:t})):s.createElement(g,o({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var d=2;d<r;d++)o[d]=t[d];return s.createElement.apply(null,o)}return s.createElement.apply(null,t)}u.displayName="MDXCreateElement"},9348:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return c},default:function(){return u}});var s=t(3117),a=t(102),r=(t(7294),t(3905)),o=["components"],i={title:"include/sleepy_discord/client.h"},l=void 0,d={unversionedId:"reference/Files/client_8h",id:"reference/Files/client_8h",title:"include/sleepy_discord/client.h",description:"Namespaces",source:"@site/docs/reference/Files/client_8h.md",sourceDirName:"reference/Files",slug:"/reference/Files/client_8h",permalink:"/sleepy-discord/docs/reference/Files/client_8h",tags:[],version:"current",frontMatter:{title:"include/sleepy_discord/client.h"},sidebar:"Reference",previous:{title:"sleepy_discord/client.cpp",permalink:"/sleepy-discord/docs/reference/Files/client_8cpp"},next:{title:"include/sleepy_discord/common_return_types.h",permalink:"/sleepy-discord/docs/reference/Files/common__return__types_8h"}},c=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Classes",id:"classes",children:[],level:2},{value:"Types",id:"types",children:[],level:2},{value:"Defines",id:"defines",children:[],level:2},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum Mode",id:"enum-mode",children:[],level:3},{value:"enum TTS",id:"enum-tts",children:[],level:3},{value:"enum RequestMode",id:"enum-requestmode",children:[],level:3},{value:"enum Intent",id:"enum-intent",children:[],level:3},{value:"using IntentsRaw",id:"using-intentsraw",children:[],level:3}],level:2},{value:"Macro Documentation",id:"macro-documentation",children:[{value:"define TOKEN_SIZE",id:"define-token_size",children:[],level:3},{value:"define SLEEPY_DEFAULT_REQUEST_MODE",id:"define-sleepy_default_request_mode",children:[],level:3},{value:"define RequestModeRequestDefine",id:"define-requestmoderequestdefine",children:[],level:3},{value:"define SLEEPY_CDN_URL",id:"define-sleepy_cdn_url",children:[],level:3},{value:"define SLEEPY_HEARTBEAT_START",id:"define-sleepy_heartbeat_start",children:[],level:3},{value:"define SLEEPY_HEARTBEAT_END",id:"define-sleepy_heartbeat_end",children:[],level:3},{value:"define SLEEPY_LOCK_CLIENT_FUNCTIONS",id:"define-sleepy_lock_client_functions",children:[],level:3}],level:2},{value:"Source code",id:"source-code",children:[],level:2}],p={toc:c};function u(e){var n=e.components,t=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,s.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"namespaces"},"Namespaces"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),(0,r.kt)("h2",{id:"classes"},"Classes"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"class"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/class_sleepy_discord_1_1_base_discord_client"},"SleepyDiscord::BaseDiscordClient")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request"},"SleepyDiscord::BaseDiscordClient::Request")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request_settings"},"SleepyDiscord::BaseDiscordClient::RequestSettings")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_raw_request_mode_type_helper"},"SleepyDiscord::BaseDiscordClient::RawRequestModeTypeHelper")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request_mode_type"},"SleepyDiscord::BaseDiscordClient::RequestModeType")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request_mode_type_3_01_async_01_4"},"SleepyDiscord::BaseDiscordClient::RequestModeType< Async >")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request_mode_type_3_01_sync_01_4"},"SleepyDiscord::BaseDiscordClient::RequestModeType< Sync >")))))),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum char"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#enum-mode"},"Mode"))," { USER_CONTROLED_THREADS = 1, USE_RUN_THREAD = 3, DEFAULT_THREADS = USER_CONTROLED_THREADS}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum char"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#enum-tts"},"TTS"))," { DisableTTS, EnableTTS, Default = DisableTTS}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#enum-requestmode"},"RequestMode"))," { UseRequestAsync = 1 << 0, UseRequestSync = 0 << 0, ThrowError = 1 << 4, AsyncQueue = 1 << 5, Async = UseRequestAsync")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum IntentsRaw"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#enum-intent"},"Intent"))," { SERVERS = 1 << 0, SERVER_MEMBERS = 1 << 1, SERVER_BANS = 1 << 2, SERVER_EMOJIS = 1 << 3, SERVER_INTEGRATIONS = 1 << 4, SERVER_WEBHOOKS = 1 << 5, SERVER_INVITES = 1 << 6, SERVER_VOICE_STATES = 1 << 7, SERVER_PRESENCES = 1 << 8, SERVER_MESSAGES = 1 << 9, SERVER_MESSAGE_REACTIONS = 1 << 10, SERVER_MESSAGE_TYPING = 1 << 11, DIRECT_MESSAGES = 1 << 12, DIRECT_MESSAGE_REACTIONS = 1 << 13, DIRECT_MESSAGE_TYPING = 1 << 14, MESSAGE_CONTENT = 1 << 15}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"using int32_t"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#using-intentsraw"},"IntentsRaw")))))),(0,r.kt)("h2",{id:"defines"},"Defines"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#define-token_size"},"TOKEN_SIZE")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#define-sleepy_default_request_mode"},"SLEEPY_DEFAULT_REQUEST_MODE")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#define-requestmoderequestdefine"},"RequestModeRequestDefine")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#define-sleepy_cdn_url"},"SLEEPY_CDN_URL")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#define-sleepy_heartbeat_start"},"SLEEPY_HEARTBEAT_START")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#define-sleepy_heartbeat_end"},"SLEEPY_HEARTBEAT_END")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8h#define-sleepy_lock_client_functions"},"SLEEPY_LOCK_CLIENT_FUNCTIONS")))))),(0,r.kt)("h2",{id:"types-documentation"},"Types Documentation"),(0,r.kt)("h3",{id:"enum-mode"},"enum Mode"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"USER_CONTROLED_THREADS"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"USE_RUN_THREAD"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DEFAULT_THREADS"),(0,r.kt)("td",{parentName:"tr",align:null},"USER_CONTROLED_THREADS"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"enum-tts"},"enum TTS"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DisableTTS"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"EnableTTS"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Default"),(0,r.kt)("td",{parentName:"tr",align:null},"DisableTTS"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"enum-requestmode"},"enum RequestMode"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UseRequestAsync"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 0"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UseRequestSync"),(0,r.kt)("td",{parentName:"tr",align:null},"0 << 0"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ThrowError"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 4"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AsyncQueue"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 5"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Async"),(0,r.kt)("td",{parentName:"tr",align:null},"UseRequestAsync"),(0,r.kt)("td",{parentName:"tr",align:null},"AsyncQueue")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Sync"),(0,r.kt)("td",{parentName:"tr",align:null},"UseRequestSync"),(0,r.kt)("td",{parentName:"tr",align:null},"ThrowError")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Sync_AsyncQueue"),(0,r.kt)("td",{parentName:"tr",align:null},"UseRequestSync"),(0,r.kt)("td",{parentName:"tr",align:null},"ThrowError")))),(0,r.kt)("h3",{id:"enum-intent"},"enum Intent"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVERS"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 0"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_MEMBERS"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 1"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_BANS"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 2"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_EMOJIS"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 3"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_INTEGRATIONS"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 4"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_WEBHOOKS"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 5"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_INVITES"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 6"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_VOICE_STATES"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 7"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_PRESENCES"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 8"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_MESSAGES"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 9"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_MESSAGE_REACTIONS"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 10"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SERVER_MESSAGE_TYPING"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 11"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DIRECT_MESSAGES"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 12"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DIRECT_MESSAGE_REACTIONS"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 13"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DIRECT_MESSAGE_TYPING"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 14"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MESSAGE_CONTENT"),(0,r.kt)("td",{parentName:"tr",align:null},"1 << 15"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"using-intentsraw"},"using IntentsRaw"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::IntentsRaw = typedef int32_t;\n")),(0,r.kt)("h2",{id:"macro-documentation"},"Macro Documentation"),(0,r.kt)("h3",{id:"define-token_size"},"define TOKEN_SIZE"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#define TOKEN_SIZE 64\n")),(0,r.kt)("h3",{id:"define-sleepy_default_request_mode"},"define SLEEPY_DEFAULT_REQUEST_MODE"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#define SLEEPY_DEFAULT_REQUEST_MODE Async;\n")),(0,r.kt)("h3",{id:"define-requestmoderequestdefine"},"define RequestModeRequestDefine"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#define RequestModeRequestDefine        template<class ParmType, class Callback> \\\n        static ReturnType doRequest(BaseDiscordClient& client, const RequestMethod method, Route path, \\\n            const std::string jsonParameters, const std::initializer_list<Part>& multipartParameters, Callback callback)\n")),(0,r.kt)("h3",{id:"define-sleepy_cdn_url"},"define SLEEPY_CDN_URL"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#define SLEEPY_CDN_URL "https://cdn.discordapp.com/"\n')),(0,r.kt)("h3",{id:"define-sleepy_heartbeat_start"},"define SLEEPY_HEARTBEAT_START"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#define SLEEPY_HEARTBEAT_START              "{"\\\n                "\\"op\\":1,"\\\n                "\\"d\\":"\n')),(0,r.kt)("h3",{id:"define-sleepy_heartbeat_end"},"define SLEEPY_HEARTBEAT_END"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#define SLEEPY_HEARTBEAT_END "}"\n')),(0,r.kt)("h3",{id:"define-sleepy_lock_client_functions"},"define SLEEPY_LOCK_CLIENT_FUNCTIONS"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#define SLEEPY_LOCK_CLIENT_FUNCTIONS                                      private:                                  \\\n                                     using BaseDiscordClient::processMessage;  \\\n                                     using BaseDiscordClient::start;           \\\n                                     using BaseDiscordClient::sendHeartbeat;   \\\n                                     using BaseDiscordClient::initialize;      \\\n                                     using BaseDiscordClient::processCloseCode;\\\n                                     using BaseDiscordClient::reconnect;       \\\n                                     using BaseDiscordClient::stopClient;      \\\n")),(0,r.kt)("h2",{id:"source-code"},"Source code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <string>\n#ifndef SLEEPY_ONE_THREAD\n#include <thread>\n#endif\n#include <memory>\n#include <unordered_map>\n#include <functional>\n#include <forward_list>\n#include <atomic>\n#include <mutex>\n\n//objects\n#include "message.h"\n#include "channel.h"\n#include "server.h"\n#include "invite.h"\n#include "webhook.h"\n#include "permissions.h"\n#include "gateway.h"\n#include "voice.h"\n#include "slash_commands.h"\n#include "stage_instance.h"\n#include "thread.h"\n\n#include "error.h"\n#include "session.h"\n#include "common_return_types.h"\n#include "message_receiver.h"\n#include "timer.h"\n#include "voice_connection.h"\n#include "asio_schedule.h"\n#include "rate_limiter.h"\n#include "compression.h"\n\nnamespace SleepyDiscord {\n#define TOKEN_SIZE 64\n\n    struct Request;\n    class BaseDiscordClient;\n\n    //to dos\n    //custom rapid json error\n    //detect cloudflare error\n    //emojis rate limits\n    //merge to master\n    //cache\n\n    //Modes\n    enum Mode : char {\n        USER_CONTROLED_THREADS = 1,\n        USE_RUN_THREAD = 3,\n        DEFAULT_THREADS = USER_CONTROLED_THREADS\n    };\n\n    enum class TTS : char {\n        DisableTTS,\n        EnableTTS,\n        Default = DisableTTS,\n    };\n\n    enum RequestMode {\n        UseRequestAsync = 1 << 0,\n        UseRequestSync = 0 << 0,\n\n        ThrowError = 1 << 4,\n        AsyncQueue = 1 << 5,\n\n        Async           = UseRequestAsync | AsyncQueue,\n        Sync            = UseRequestSync | ThrowError,\n        Sync_AsyncQueue = UseRequestSync | ThrowError | AsyncQueue, //old behavior for backwards compat\n    };\n\n    using IntentsRaw = int32_t;\n\n    enum Intent : IntentsRaw {\n        SERVERS                  = 1 << 0,\n        SERVER_MEMBERS           = 1 << 1,\n        SERVER_BANS              = 1 << 2,\n        SERVER_EMOJIS            = 1 << 3,\n        SERVER_INTEGRATIONS      = 1 << 4,\n        SERVER_WEBHOOKS          = 1 << 5,\n        SERVER_INVITES           = 1 << 6,\n        SERVER_VOICE_STATES      = 1 << 7,\n        SERVER_PRESENCES         = 1 << 8,\n        SERVER_MESSAGES          = 1 << 9,\n        SERVER_MESSAGE_REACTIONS = 1 << 10,\n        SERVER_MESSAGE_TYPING    = 1 << 11,\n        DIRECT_MESSAGES          = 1 << 12,\n        DIRECT_MESSAGE_REACTIONS = 1 << 13,\n        DIRECT_MESSAGE_TYPING    = 1 << 14,\n        MESSAGE_CONTENT          = 1 << 15,\n    };\n\n    class BaseDiscordClient : public GenericMessageReceiver {\n    public:\n        BaseDiscordClient() = default;\n        BaseDiscordClient(const std::string _token) { start(_token); }\n        ~BaseDiscordClient();\n\n        //important note, all requests on sync mode throw on an http error\n\n        using RequestCallback = std::function<void(Response)>;\n        Response request(const RequestMethod method, Route path, const std::string jsonParameters = "",\n            const std::vector<Part>& multipartParameters = {},\n            RequestCallback callback = nullptr, const RequestMode mode = Sync_AsyncQueue);\n        struct Request {\n            BaseDiscordClient& client;\n            const RequestMethod method;\n            const Route url;\n            const std::string jsonParameters;\n            const std::vector<Part> multipartParameters;\n            const BaseDiscordClient::RequestCallback callback;\n            RequestMode mode;\n            inline void operator()() const {\n                client.request(method, url, jsonParameters, multipartParameters, callback, mode);\n            }\n        };\n\n        template<class ParmType>\n        void requestAsync(const RequestMethod method, Route path, std::function<void(ParmType)> callback, const std::string jsonParameters = "",\n            const std::vector<Part>& multipartParameters = {}, const RequestMode mode = Async) {\n            postTask(static_cast<PostableTask>(\n                Request{ *this, method, path, jsonParameters, multipartParameters, callback ? RequestCallback([callback](Response r) {\n                    callback(static_cast<ParmType>(r));\n                }) : RequestCallback(nullptr), mode }\n            ));\n        }\n\n        template<class ParmType>\n        Response requestSync(const RequestMethod method, Route path, std::function<void(ParmType)> callback, const std::string jsonParameters = "",\n            const std::vector<Part>& multipartParameters = {}, const RequestMode mode = Sync) {\n            return request(method, path, jsonParameters, multipartParameters, callback ? RequestCallback([callback](Response r) {\n                callback(static_cast<ParmType>(r));\n            }) : RequestCallback(nullptr), mode );\n        }\n\n        const Route path(const char* source, std::initializer_list<std::string> values = {});\n\n#ifndef SLEEPY_DEFAULT_REQUEST_MODE\n    #ifdef SLEEPY_DEFAULT_REQUEST_MODE_ASYNC\n        #define SLEEPY_DEFAULT_REQUEST_MODE Async;\n    #elif defined(SLEEPY_DEFAULT_REQUEST_MODE_SYNC)\n        #define SLEEPY_DEFAULT_REQUEST_MODE Sync;\n    #else\n        #define SLEEPY_DEFAULT_REQUEST_MODE Async;\n    #endif\n#endif\n\n        template<class _ParmType>\n        struct RequestSettings {\n            RequestMode mode = SLEEPY_DEFAULT_REQUEST_MODE;\n            using ParmType = _ParmType;\n            using Callback = std::function<void(ParmType)>;\n            Callback callback = nullptr;\n\n            RequestSettings(RequestMode r) : mode(r) {}\n            RequestSettings(Callback c) : mode(Async), callback(c) {}\n            RequestSettings(RequestMode r, Callback c) : mode(r), callback(c) {}\n            RequestSettings() {}; //for some reason = default doesn\'t work\n        };\n\n        template<class RequestSettingsClass>\n        Response request(const RequestMethod method, Route path, RequestSettingsClass& settings,\n            const std::string jsonParameters = "", const std::initializer_list<Part>& multipartParameters = {}) {\n            if (settings.mode & UseRequestAsync) {\n                requestAsync<\n                    typename RequestSettingsClass::ParmType\n                >(method, path, settings.callback, jsonParameters, multipartParameters, settings.mode);\n            } else {\n                if (settings.callback)\n                    //having an invalid callback here would cause bugs\n                    return requestSync<\n                        typename RequestSettingsClass::ParmType\n                    >(method, path, settings.callback, jsonParameters, multipartParameters, settings.mode);\n                else\n                    return request(method, path, jsonParameters, multipartParameters, nullptr, settings.mode);\n            }\n            return Response();\n        }\n\n        template<RequestMode mode, class type>\n        struct RawRequestModeTypeHelper {\n            using ReturnType = type;\n            static type doRequest() {}\n        };\n\n        #define RequestModeRequestDefine template<class ParmType, class Callback> \\\n        static ReturnType doRequest(BaseDiscordClient& client, const RequestMethod method, Route path, \\\n            const std::string jsonParameters, const std::initializer_list<Part>& multipartParameters, Callback callback)\n\n        template<RequestMode mode> struct RequestModeType : RawRequestModeTypeHelper<Sync, void> {};\n\n        template<RequestMode mode, class ParmType = void, class Callback = RequestCallback>\n        typename RequestModeType<mode>::ReturnType request(const RequestMethod method, Route path, Callback callback,\n            const std::string jsonParameters = "", const std::initializer_list<Part>& multipartParameters = {}\n            ) {\n            return RequestModeType<mode>::template doRequest<ParmType, Callback>(*this, method, path, jsonParameters, multipartParameters, callback);\n        }\n\n        void testFunction(std::string teststring);\n\n        //gateway functions\n        ObjectResponse<Gateway> getGateway(RequestSettings<ObjectResponse<Gateway>> settings = {});\n\n        //channel functions\n        ObjectResponse<Channel     > getChannel              (Snowflake<Channel> channelID                                                                                 , RequestSettings<ObjectResponse<Channel>> settings = {});\n        ObjectResponse<Channel     > editChannel             (Snowflake<Channel> channelID, std::string name = "", std::string topic = ""                                  , RequestSettings<ObjectResponse<Channel>> settings = {});\n        ObjectResponse<Channel     > editChannelName         (Snowflake<Channel> channelID, std::string name                                                               , RequestSettings<ObjectResponse<Channel>> settings = {});\n        ObjectResponse<Channel     > editChannelTopic        (Snowflake<Channel> channelID, std::string topic                                                              , RequestSettings<ObjectResponse<Channel>> settings = {});\n        ObjectResponse<Channel     > deleteChannel           (Snowflake<Channel> channelID                                                                                 , RequestSettings<ObjectResponse<Channel>> settings = {});\n        enum class GetMessagesKey {na, around, before, after, limit};\n        ArrayResponse <Message     > getMessages             (Snowflake<Channel> channelID, GetMessagesKey when, Snowflake<Message> messageID, uint8_t limit = 0           , RequestSettings<ArrayResponse<Message>> settings = {});\n        ObjectResponse<Message     > getMessage              (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<ObjectResponse<Message>> settings = {});  //to do add more then one message return\n        const Embed createInvalidEmbed() {\n            return Embed::Flag::INVALID_EMBED;\n        }\n        //maybe move this to message.h\n        ObjectResponse<Message     > sendMessage             (Snowflake<Channel> channelID, std::string message, std::vector<Embed> embeds, MessageReference replyingTo = {}, TTS tts = TTS::Default, RequestSettings<ObjectResponse<Message>> settings = {});\n        ObjectResponse<Message     > sendMessage             (Snowflake<Channel> channelID, std::string message, Embed embeds, MessageReference replyingTo = {}, TTS tts = TTS::Default, RequestSettings<ObjectResponse<Message>> settings = {});\n        ObjectResponse<Message     > sendMessage             (SendMessageParams params                                                                                     , RequestSettings<ObjectResponse<Message>> settings = {});\n        ObjectResponse<Message     > uploadFile              (Snowflake<Channel> channelID, std::string fileLocation, std::string message, std::vector<Embed> embeds = {}, MessageReference replyingTo = {}, RequestSettings<ObjectResponse<Message>> settings = {});\n        ObjectResponse<Message     > uploadFile              (SendMessageParams params, std::string fileLocation                                                           , RequestSettings<ObjectResponse<Message>> settings = {});\n        BoolResponse                 addReaction             (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji                                , RequestSettings<BoolResponse           > settings = {});\n        BoolResponse                 removeReaction          (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji, Snowflake<User> userID = "@me");\n        ArrayResponse <User        > getReactions            (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji                                , RequestSettings<ArrayResponse<Reaction>> settings = {});\n        StandardResponse             removeAllReactions      (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<StandardResponse       > settings = {});\n        ObjectResponse<Message     > editMessage             (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string newMessage, std::vector<Embed> embeds = {}, RequestSettings<ObjectResponse<Message>> settings = {});\n        ObjectResponse<Message     > editMessage             (EditMessageParams params, RequestSettings<ObjectResponse<Message>> settings = {});\n        BoolResponse                 deleteMessage           (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<BoolResponse           > settings = {});\n        BoolResponse                 bulkDeleteMessages      (Snowflake<Channel> channelID, std::vector<Snowflake<Message>> messageIDs                                     , RequestSettings<BoolResponse           > settings = {});\n        /*allow is a bitwise value of all allowed permissions\n        deny is a bitwise value of all deisallowed permissions\n        type is "member" for a user or "role" for a role*/\n        BoolResponse                 editChannelPermissions  (Snowflake<Channel> channelID, Snowflake<Overwrite> overwriteID, int allow, int deny, std::string type);           //to do test this\n        ArrayResponse <Invite      > getChannelInvites       (Snowflake<Channel> channelID                                                                                 , RequestSettings<ArrayResponse<Invite  >> settings = {});\n        ObjectResponse<Invite      > createChannelInvite     (Snowflake<Channel> channelID, const uint64_t maxAge = 0, const uint64_t maxUses = 0, const bool temporary = false, const bool unique = false);\n        BoolResponse                 removeChannelPermission (Snowflake<Channel> channelID, std::string ID                                                                 , RequestSettings<BoolResponse           > settings = {});\n        BoolResponse                 sendTyping              (Snowflake<Channel> channelID                                                                                 , RequestSettings<BoolResponse           > settings = {});\n        ArrayResponse <Message     > getPinnedMessages       (Snowflake<Channel> channelID                                                                                 , RequestSettings<ArrayResponse<Message >> settings = {});\n        BoolResponse                 pinMessage              (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<BoolResponse           > settings = {});\n        BoolResponse                 unpinMessage            (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<BoolResponse           > settings = {});\n        StandardResponse             addRecipient            (Snowflake<Channel> channelID, Snowflake<User> userID                                                         , RequestSettings<StandardResponse       > settings = {});\n        StandardResponse             removeRecipient         (Snowflake<Channel> channelID, Snowflake<User> userID                                                         , RequestSettings<StandardResponse       > settings = {});\n        ObjectResponse<Channel     > startThreadMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string name, int autoArchiveDuration = 0, int rateLimitPerUser = -1, RequestSettings<ObjectResponse<Channel>> settings = {});\n        BoolResponse                 joinThread              (Snowflake<Channel> channelID, RequestSettings<BoolResponse> settings = {});\n        BoolResponse                 addThreadMember         (Snowflake<Channel> channelID, Snowflake<User> userID, RequestSettings<BoolResponse> settings = {});\n        BoolResponse                 leaveThread             (Snowflake<Channel> channelID, RequestSettings<BoolResponse> settings = {});\n        BoolResponse                 removeThreadMember      (Snowflake<Channel> channelID, Snowflake<User> userID, RequestSettings<BoolResponse> settings = {});\n        ObjectResponse<ThreadMember> getThreadMember(Snowflake<Channel> channelID, Snowflake<User> userID, bool withMember = false, RequestSettings<ObjectResponse<ThreadMember>> settings = {});\n\n        //IntelliSense Help\n        /*functions with more then one name to make life easy for users that use IntelliSense*/\n        inline BoolResponse          deleteReaction          (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji) { return removeReaction         (channelID, messageID, emoji); }\n        inline StandardResponse      deleteAllReactions      (Snowflake<Channel> channelID, Snowflake<Message> messageID                   ) { return removeAllReactions     (channelID, messageID       ); }\n        inline BoolResponse          deleteChannelPermission (Snowflake<Channel> channelID, std::string               ID                   ) { return removeChannelPermission(channelID,        ID       ); }\n        inline StandardResponse      deleteRecipient         (Snowflake<Channel> channelID, Snowflake<User   >    _userID                  ) { return removeRecipient        (channelID,   _userID       ); }\n        //For Convenience\n        inline ObjectResponse<Message> editMessage(Message message, std::string newMessage, std::vector<Embed> embeds = {}) { return editMessage(message.channelID, message.ID, newMessage, embeds); }\n        inline ObjectResponse<Message> sendMessage(Snowflake<Channel> channelID, std::string message, RequestSettings<ObjectResponse<Message>> settings) {\n            return sendMessage(channelID, message, std::vector<Embed>{}, MessageReference{}, TTS::Default, settings);\n        }\n        inline ObjectResponse<Message> sendMessage(Snowflake<Channel> channelID, std::string message) {\n            return sendMessage(channelID, message, std::vector<Embed>{}, MessageReference{}, TTS::Default, {});\n        }\n\n        //server functions\n        //ObjectResponse<Server      > createServer to do add this\n        ObjectResponse<Server      > getServer               (Snowflake<Server> serverID                                                         , RequestSettings<ObjectResponse<Server      >> settings = {});\n        //edit Server       //to do add this\n        ObjectResponse<Server      > deleteServer            (Snowflake<Server> serverID                                                         , RequestSettings<ObjectResponse<Server      >> settings = {});\n        ArrayResponse <Channel     > getServerChannels       (Snowflake<Server> serverID                                                         , RequestSettings<ArrayResponse<Channel      >> settings = {});\n        ObjectResponse<Channel     > createTextChannel       (Snowflake<Server> serverID, std::string name                                       , RequestSettings<ObjectResponse<Channel     >> settings = {});\n        ObjectResponse<Channel     > createChannel       (Snowflake<Server> serverID, std::string name, Channel::ChannelType Type                , RequestSettings<ObjectResponse<Channel     >> settings = {});\n        ArrayResponse <Channel     > editChannelPositions    (Snowflake<Server> serverID, std::vector<std::pair<std::string, uint64_t>> positions, RequestSettings<ArrayResponse<Channel      >> settings = {});\n        ObjectResponse<ServerMember> getMember               (Snowflake<Server> serverID, Snowflake<User> userID                                 , RequestSettings<ObjectResponse<ServerMember>> settings = {});\n        ArrayResponse <ServerMember> listMembers             (Snowflake<Server> serverID, uint16_t limit = 0, std::string after = ""             , RequestSettings<ArrayResponse<ServerMember >> settings = {});\n        ObjectResponse<ServerMember> addMember               (Snowflake<Server> serverID, Snowflake<User> userID, std::string accesToken, std::string nick = "", std::vector<Role> roles = {}, bool mute = false, bool deaf = false); //to do test this\n        BoolResponse                 editMember              (Snowflake<Server> serverID, Snowflake<User> userID, std::string nickname = "", std::vector<Snowflake<Role>> roles = {}, int8_t mute = -1, int8_t deaf = -1, Snowflake<Channel> channelID = {});\n        BoolResponse                 muteServerMember        (Snowflake<Server> serverID, Snowflake<User> userID, bool mute = true               , RequestSettings<BoolResponse                 > settings = {});  //to do test this\n        BoolResponse                 editNickname            (Snowflake<Server> serverID, std::string newNickname                                , RequestSettings<BoolResponse                 > settings = {});\n        BoolResponse                 addRole                 (Snowflake<Server> serverID, Snowflake<User> userID, Snowflake<Role> roleID         , RequestSettings<BoolResponse                 > settings = {});\n        BoolResponse                 removeRole              (Snowflake<Server> serverID, Snowflake<User> userID, Snowflake<Role> roleID         , RequestSettings<BoolResponse                 > settings = {});\n        BoolResponse                 kickMember              (Snowflake<Server> serverID, Snowflake<User> userID                                 , RequestSettings<BoolResponse                 > settings = {});\n        ArrayResponse <User        > getBans                 (Snowflake<Server> serverID                                                         , RequestSettings<ArrayResponse<User          >> settings = {});  //to do test this\n        BoolResponse                 banMember               (Snowflake<Server> serverID, Snowflake<User> userID, int deleteMessageDays = -1, std::string reason = "", RequestSettings<BoolResponse> settings = {});\n        BoolResponse                 unbanMember             (Snowflake<Server> serverID, Snowflake<User> userID                                 , RequestSettings<BoolResponse                 > settings = {});\n        ArrayResponse <Role        > getRoles                (Snowflake<Server> serverID                                                         , RequestSettings<ArrayResponse<Role          >> settings = {});\n        ObjectResponse<Role        > createRole              (Snowflake<Server> serverID, std::string name = "", Permission permissions = Permission::NONE, unsigned int color = 0, bool hoist = false, bool mentionable = false);\n        ArrayResponse <Role        > editRolePosition        (Snowflake<Server> serverID, std::vector<std::pair<std::string, uint64_t>> positions, RequestSettings<ArrayResponse<Role>> settings = {});  //to do test this\n        StringResponse               editRole                (Snowflake<Server> serverID, Snowflake<Role> roleID, std::string name = "", Permission permissions = Permission::NONE, uint32_t color = 1 << 24, int8_t hoist = -1, int8_t mentionable = -1);\n        BoolResponse                 deleteRole              (Snowflake<Server> serverID, Snowflake<Role> roleID                                 , RequestSettings<BoolResponse                 > settings = {});\n        //get prune count   needs testing to know what object they are talking about\n        StandardResponse             pruneMembers            (Snowflake<Server> serverID, const unsigned int numOfDays                           , RequestSettings<StandardResponse             > settings = {});  //to do test\n        ArrayResponse <VoiceRegion > getVoiceRegions         (                                                                                     RequestSettings<ArrayResponse<VoiceRegion   >> settings = {});\n        ArrayResponse <Invite      > getServerInvites        (Snowflake<Server> serverID                                                         , RequestSettings<ArrayResponse<Invite        >> settings = {});\n        StringResponse               getIntegrations         (Snowflake<Server> serverID                                                         , RequestSettings<StringResponse               > settings = {});  //needs whatever a integration class is  //to do test\n        BoolResponse                 createIntegration       (Snowflake<Server> serverID, std::string type, std::string integrationID            , RequestSettings<BoolResponse                 > settings = {});  //to do test\n        BoolResponse                 editIntergration        (Snowflake<Server> serverID, std::string integrationID, int expireBegavior, int expireGracePeriod, bool enbleEmoticons); //to do test\n        BoolResponse                 deleteIntegration       (Snowflake<Server> serverID, std::string integrationID                              , RequestSettings<BoolResponse                 > settings = {});  //to do test this\n        BoolResponse                 syncIntegration         (Snowflake<Server> serverID, std::string integrationID                              , RequestSettings<BoolResponse                 > settings = {});  //to do test this\n        ObjectResponse<ServerWidget > getServerWidget          (Snowflake<Server> serverID                                                       , RequestSettings<ObjectResponse<ServerWidget>> settings = {});\n        //edit server embed   I don\'t know what the perms are\n\n        //Invite functions\n        ObjectResponse<Invite      > inviteEndpoint          (RequestMethod method, std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings = {});\n        ObjectResponse<Invite      > getInvite               (std::string inviteCode                      , RequestSettings<ObjectResponse<Invite>> settings = {});  //to do test this\n        ObjectResponse<Invite      > deleteInvite            (std::string inviteCode                      , RequestSettings<ObjectResponse<Invite>> settings = {});  //to do test this\n        ObjectResponse<Invite      > acceptInvite            (std::string inviteCode                      , RequestSettings<ObjectResponse<Invite>> settings = {}); //not available to bot accounts  //to do test this\n\n        //User functions\n        ObjectResponse<User        > getCurrentUser          (                            RequestSettings<ObjectResponse<User     >> settings = {});\n        ObjectResponse<User        > getUser                 (Snowflake<User> userID    , RequestSettings<ObjectResponse<User     >> settings = {});\n        //User editCurrentUser();\n        ArrayResponse <Server>     getServers                (                            RequestSettings<ArrayResponse<Server    >> settings = {});\n        BoolResponse               leaveServer               (Snowflake<Server> serverID, RequestSettings<BoolResponse             > settings = {});\n        ArrayResponse <Channel   > getDirectMessageChannels  (                            RequestSettings<ArrayResponse<Channel   >> settings = {});\n        ObjectResponse<Channel   > createDirectMessageChannel(std::string recipientID   , RequestSettings<ObjectResponse<Channel  >> settings = {});\n        //ObjectResponse<DMChannel > createGroupDirectMessageChannel(std:vector<std::string> accessTokens, ) to do add this\n        ArrayResponse <Connection> getUserConnections        (                            RequestSettings<ArrayResponse<Connection>> settings = {});\n\n        //Voice Functions\n        //getVoiceRegions\n\n        //Webhook functions\n        ObjectResponse<Webhook> createWebhook                (Snowflake<Channel> channelID, std::string name, std::string avatar = "", RequestSettings<ObjectResponse<Webhook>> settings = {});  //to do test this\n        ArrayResponse <Webhook> getChannelWebhooks           (Snowflake<Channel> channelID                                           , RequestSettings<ArrayResponse <Webhook>> settings = {});\n        ArrayResponse <Webhook> getServerWebhooks            (Snowflake<Server> serverID                                             , RequestSettings<ArrayResponse <Webhook>> settings = {});\n        ObjectResponse<Webhook> getWebhook                   (Snowflake<Webhook> webhookID, std::string webhookToken = ""            , RequestSettings<ObjectResponse<Webhook>> settings = {});  //to do test this\n        ObjectResponse<Webhook> editWebhook                  (Snowflake<Webhook> webhookID, std::string webhookToken = "", std::string name = "", std::string avatar = "");    //you can leave token or name as null //to do test this\n        BoolResponse            deleteWebhook                (Snowflake<Webhook> webhookID, std::string webhookToken = ""            , RequestSettings<BoolResponse           > settings = {});\n        ObjectResponse<Webhook> requestExecuteWebhook        (Snowflake<Webhook> webhookID, std::string webhookToken, std::pair<std::string, std::string> pair, bool wait, std::string username, std::string avatar_url, bool tts);     //note: it\'s possiable to have both a file and embeds\n        ObjectResponse<Webhook> executeWebhook               (Snowflake<Webhook> webhookID, std::string webhookToken, std::string content, bool wait = false, std::string username = "", std::string avatar_url = "", bool tts = false);       //to do test this\n        ObjectResponse<Webhook> executeWebhook               (Snowflake<Webhook> webhookID, std::string webhookToken, std::vector<Embed> embeds, bool wait = false, std::string username = "", std::string avatar_url = "", bool tts = false); //to do test this\n        ObjectResponse<Webhook> executeWebhook               (Snowflake<Webhook> webhookID, std::string webhookToken, filePathPart file, bool wait = false, std::string username = "", std::string avatar_url = "", bool tts = false);         //to do test this\n\n        //slash commands\n        //Command Options have issues with copying so to avoid any copying, we use templates for the edit and create functions\n        //This way, we can use use the EmptyOptions type as default and still let uses options via a vector or list without any copying\n        template<typename Options = const AppCommand::EmptyOptions>\n        ObjectResponse<AppCommand> createGlobalAppCommand(\n            Snowflake<DiscordObject>::RawType applicationID, std::string name, std::string description, Options options = (std::nullptr_t)nullptr,\n            bool defaultPermission = true, AppCommand::Type type = AppCommand::Type::NONE,\n            RequestSettings<ObjectResponse<AppCommand>> settings = {}\n        ) {\n            return ObjectResponse<AppCommand>{ request(Post, path("applications/{application.id}/commands", { applicationID }), settings,\n                createApplicationCommandBody(name, description, options, defaultPermission, type)) };\n        }\n        template<typename Options = const AppCommand::EmptyOptions>\n        ObjectResponse<AppCommand> editGlobalAppCommand(\n            Snowflake<DiscordObject>::RawType applicationID, Snowflake<AppCommand> commandID, std::string name, std::string description, Options options = (std::nullptr_t)nullptr,\n            bool defaultPermission = true, AppCommand::Type type = AppCommand::Type::NONE,\n            RequestSettings<ObjectResponse<AppCommand>> settings = {}\n        ) {\n            return ObjectResponse<AppCommand>{ request(Patch,\n                path("applications/{application.id}/commands/{command.id}", { applicationID, commandID }), settings,\n                createApplicationCommandBody(name, description, options, defaultPermission, type, true)) };\n        }\n        ArrayResponse<AppCommand> getGlobalAppCommands(Snowflake<DiscordObject>::RawType applicationID, RequestSettings<ArrayResponse<AppCommand>> settings = {});\n        ObjectResponse<AppCommand> getGlobalAppCommand(Snowflake<DiscordObject>::RawType applicationID, Snowflake<AppCommand> commandID, RequestSettings<ObjectResponse<AppCommand>> settings = {});\n        BoolResponse deleteGlobalAppCommand(Snowflake<DiscordObject>::RawType applicationID, Snowflake<AppCommand> commandID, RequestSettings<BoolResponse> settings = {});\n        template<typename Options = const AppCommand::EmptyOptions>\n        ObjectResponse<AppCommand> createServerAppCommand(\n            Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, std::string name, std::string description,\n            Options options = (std::nullptr_t)nullptr, bool defaultPermission = true, AppCommand::Type type = AppCommand::Type::NONE,\n            RequestSettings<ObjectResponse<AppCommand>> settings = {}\n        ) {\n            return ObjectResponse<AppCommand>{ request(Post,\n                path("applications/{application.id}/guilds/{guild.id}/commands", { applicationID, serverID }), settings,\n                createApplicationCommandBody(name, description, options, defaultPermission, type, true)) };\n        }\n        template<typename Options = const AppCommand::EmptyOptions>\n        ObjectResponse<AppCommand> editServerAppCommand(\n            Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, std::string name,\n            std::string description, Options options = (std::nullptr_t)nullptr,\n            RequestSettings<ObjectResponse<AppCommand>> settings = {}\n        ) {\n            return ObjectResponse<AppCommand>{ request(Patch,\n                path("applications/{application.id}/guilds/{guild.id}/commands/{command.id}", { applicationID, serverID, commandID }), settings,\n                createApplicationCommandBody(name, description, options, true)) };\n        }\n        ArrayResponse<AppCommand> getServerAppCommands(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, RequestSettings<ArrayResponse<AppCommand>> settings = {});\n        ObjectResponse<AppCommand> getServerAppCommand(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<ObjectResponse<AppCommand>> settings = {});\n        BoolResponse deleteServerAppCommand(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<BoolResponse> settings = {});\n        template<typename Type>\n        BoolResponse createInteractionResponse(Snowflake<Interaction> interactionID, std::string token, Type response, RequestSettings<BoolResponse> settings = {}) {\n            static_assert(std::is_same<InteractionCallbackType, decltype(response.type)>::value, "response needs to be a Interaction::Response Type");\n            return { request(Post, path("interactions/{interaction.id}/{interaction.token}/callback", { interactionID, token }), settings, json::stringifyObj(response)), EmptyRespFn() };\n        }\n        ObjectResponse<Message> editOriginalInteractionResponse(Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, EditWebhookParams params, RequestSettings<BoolResponse> settings = {});\n        BoolResponse deleteOriginalInteractionResponse(Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, RequestSettings<BoolResponse> settings = {});\n        ObjectResponse<Message> createFollowupMessage(Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, FollowupMessage params, RequestSettings<BoolResponse> settings = {});\n        ObjectResponse<Message> editFollowupMessage(Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, Snowflake<Message> messageID, EditWebhookParams params, RequestSettings<BoolResponse> settings = {});\n        BoolResponse deleteFollowupMessage(Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, Snowflake<Message> messageID, RequestSettings<BoolResponse> settings = {});\n        BoolResponse batchEditAppCommandPermissions(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, std::vector<ServerAppCommandPermissions> permissions, RequestSettings<BoolResponse> settings = {});\n        BoolResponse editServerAppCommandPermission(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, std::vector<AppCommand::Permissions> permissions, RequestSettings<BoolResponse> settings = {});\n        ArrayResponse<ServerAppCommandPermissions> getServerAppCommandPermissions(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, RequestSettings<ArrayResponse<ServerAppCommandPermissions>> settings = {});\n        ObjectResponse<ServerAppCommandPermissions> getAppCommandPermissions(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<ObjectResponse<ServerAppCommandPermissions>> settings = {});\n        template<typename Options = const AppCommand::EmptyOptions>\n        ObjectResponse<AppCommand> createAppCommand(\n            Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, std::string name, std::string description,\n            Options options = (std::nullptr_t)nullptr, bool defaultPermission = true, AppCommand::Type type = AppCommand::Type::NONE,\n            RequestSettings<ObjectResponse<AppCommand>> settings = {}\n        ) {\n            if (serverID.empty()) return createGlobalAppCommand(applicationID, name, description, options, defaultPermission, type, settings);\n            return createServerAppCommand(applicationID, serverID, name, description, options, defaultPermission, type, settings);\n        }\n        template<typename Options = const AppCommand::EmptyOptions>\n        ObjectResponse<AppCommand> editAppCommand(\n            Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, std::string name,\n            std::string description, Options options = (std::nullptr_t)nullptr,\n            RequestSettings<ObjectResponse<AppCommand>> settings = {}\n        ) {\n            if (serverID.empty()) return editGlobalAppCommand(applicationID, commandID, name, description, options, settings);\n            return editServerAppCommand(applicationID, serverID, commandID, name, description, options, settings);\n        }\n        ArrayResponse<AppCommand> getAppCommands(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, RequestSettings<ArrayResponse<AppCommand>> settings = {});\n        ObjectResponse<AppCommand> getAppCommand(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<ObjectResponse<AppCommand>> settings = {});\n        BoolResponse deleteAppCommand(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<BoolResponse> settings = {});\n        BoolResponse bulkOverwriteServerAppCommands(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, std::vector<AppCommand> commands, RequestSettings<BoolResponse> settings = {});\n        BoolResponse bulkOverwriteGlobalAppCommands(Snowflake<DiscordObject>::RawType applicationID, std::vector<AppCommand> commands, RequestSettings<BoolResponse> settings = {});\n\n        //stage instances\n        ObjectResponse<User> createStageInstance(Snowflake<Channel> channelID, std::string topic, StageInstance::PrivacyLevel privacyLevel = StageInstance::PrivacyLevel::NotSet, RequestSettings<ObjectResponse<User>> settings = {});\n        ObjectResponse<StageInstance> getStageInstance(Snowflake<Channel> channelID, RequestSettings<ObjectResponse<StageInstance>> settings = {});\n        BoolResponse editStageInstance(Snowflake<Channel> channelID, std::string topic, StageInstance::PrivacyLevel privacyLevel = StageInstance::PrivacyLevel::NotSet, RequestSettings<BoolResponse> settings = {});\n        BoolResponse deleteStageInstance(Snowflake<Channel> channelID, RequestSettings<BoolResponse> settings = {});\n\n        //websocket functions\n        void updateStatus(std::string gameName = "", uint64_t idleSince = 0, Status status = online, bool afk = false);\n        void requestServerMembers(ServerMembersRequest request);\n\n        //CDN stuff\n        #define SLEEPY_CDN_URL "https://cdn.discordapp.com/"\n        static inline constexpr nonstd::string_view getCDN_URL() {\n            return { SLEEPY_CDN_URL, sizeof(SLEEPY_CDN_URL) };  \n        }\n        void getServerBanner(Snowflake<Server> serverID, std::string serverBanner, std::string format, std::function<void(StandardResponse&)> callback);\n        inline void getServerBanner(Server& server, std::string format) { return getServerBanner(server.ID, server.banner, format, [](StandardResponse&){}); }\n\n        void waitTilReady();  \n        const bool isReady() { return ready; }\n        const bool isQuiting() { return quiting; }\n        const bool isBot() { return bot; }\n        const Snowflake<User> getID() { return userID; }\n        void setShardID(int _shardID, int _shardCount); //Note: must be called before run or reconnect\n        const int getShardID() { return shardID; }\n        const int getShardCount() { return shardCount; }\n        const bool hasIntents() { return intentsIsSet; }\n        const IntentsRaw getIntents() { return intents; }\n        void setIntents(IntentsRaw newIntents) { intentsIsSet = true; intents = static_cast<Intent>(newIntents); }\n        void quit() { quit(false); }    //public function for diconnecting\n        virtual void run();\n\n        //array of intents\n        template<class Container, typename T = typename Container::value_type>\n        void setIntents(const Container& listOfIntents) {\n            IntentsRaw target = 0;\n            for (Intent intent : listOfIntents)\n                target = target | static_cast<IntentsRaw>(intent);\n            setIntents(target);\n        }\n\n        //parameter pack of intents\n        template<typename... Types>\n        void setIntents(Intent first, Intent second, Types... others) {\n            std::initializer_list<Intent> intents = { first, second, others... };\n            setIntents(intents);\n        }\n\n        template <class Handler, class... Types>\n        void useCompression(Types&&... arguments) {\n            compressionHandler = std::unique_ptr<GenericCompression>(\n                new Handler(std::forward<Types>(arguments)...));\n            if (useTrasportConnection == static_cast<int8_t>(-1)) //if not set yet\n                useTrasportConnection = true;\n        }\n\n        void useCompression(bool value = true) {\n#ifdef SLEEPY_DEFAULT_COMPRESSION\n            if (value) useCompression<DefaultCompression>();\n            else scheduleHandler = nullptr;\n#else\n            assert(((void)"No default compress handler, use zlib-ng or use template function instead", value == false));\n#endif\n        }\n\n        //time\n        template <class Handler, class... Types>\n        inline void setScheduleHandler(Types&&... arguments) {\n            scheduleHandler = std::unique_ptr<GenericScheduleHandler>(\n                new Handler(std::forward<Types>(arguments)...)\n            );\n        }\n        inline GenericScheduleHandler& getScheduleHandler() { return *scheduleHandler; }\n\n        enum AssignmentType : bool {\n            TilDueTime = 0,\n            EpochTime  = 1,\n        };\n        virtual Timer  schedule(TimedTask                 code   , const time_t millisecondsTilDueTime);\n        inline  Timer  schedule(TimedTask                 code   , const time_t milliseconds, AssignmentType mode) {\n            return     schedule(code, mode == TilDueTime ? milliseconds : milliseconds - getEpochTimeMillisecond());\n        }\n        inline  Timer  schedule(void (BaseDiscordClient::*code)(), const time_t milliseconds, AssignmentType mode = TilDueTime) {\n            return     schedule(std::bind(code, this), milliseconds, mode);\n        }\n        inline  void  unschedule(Timer& timer) { timer.stop(); }\n\n        typedef TimedTask PostableTask;\n        virtual void postTask(PostableTask code) {\n            schedule(code, 0);\n        }\n\n#ifdef SLEEPY_VOICE_ENABLED\n        //\n        //voice\n        //\n\n        friend VoiceConnection;\n\n        enum VoiceMode {\n            normal = 0,\n            mute = 1 << 0,\n            deafen = 1 << 1\n        };\n\n        VoiceContext& createVoiceContext(Snowflake<Server> server, Snowflake<Channel> channel, BaseVoiceEventHandler* eventHandler = nullptr);\n        inline VoiceContext& createVoiceContext(Snowflake<Channel> channel, BaseVoiceEventHandler* eventHandler = nullptr) {\n            return createVoiceContext("", channel, eventHandler);\n        }\n        void connectToVoiceChannel(VoiceContext& voiceContext, VoiceMode settings = normal);\n        VoiceContext& connectToVoiceChannel(Snowflake<Server> server, Snowflake<Channel> channel, VoiceMode settings = normal);\n        VoiceContext& connectToVoiceChannel(Snowflake<Channel> channel, VoiceMode settings = normal) {\n            return connectToVoiceChannel("", channel, settings);\n        }\n        inline void disconnectVoiceConnection(VoiceConnection & connection) {\n            connection.disconnect();\n        }\n\n        template<class Function>\n        void disconnectVoiceConnection_if(Function function) {\n            auto i = std::find_if(voiceConnections.begin(), voiceConnections.end(), function);\n            if (i != voiceConnections.end())\n                disconnectVoiceConnection(*i);\n        }\n\n        inline void disconnectVoiceContext(VoiceContext & context) {\n            disconnectVoiceConnection_if([&context](VoiceConnection& connection) {\n                return connection.getContext() == context;\n            });\n        }\n\n        inline void disconnectFromVoiceChannel(Snowflake<Channel>& channelID) {\n            disconnectVoiceConnection_if([&channelID](VoiceConnection& connection) {\n                return connection.getContext().getChannelID() == channelID;\n            });\n        }\n\n        inline void disconnectServerVoiceConnections(Snowflake<Server>& serverID) {\n            disconnectVoiceConnection_if([&serverID](VoiceConnection& connection) {\n                return connection.getContext().getServerID() == serverID;\n            });\n        }\n#endif\n\n        //Caching\n        std::shared_ptr<ServerCache> createServerCache();\n        void setServerCache(std::shared_ptr<ServerCache> cache);\n        inline std::shared_ptr<ServerCache>& getServerCache() {\n            return serverCache;\n        }\n\n    protected:\n        //Rest events\n        virtual void onDepletedRequestSupply(const Route::Bucket& bucket, double timeTilReset);\n        virtual void onExceededRateLimit(bool global, double timeTilRetry, Request request, bool& continueRequest);\n\n        /* list of events\n        READY\n        RESUMED\n        GUILD_CREATE\n        GUILD_DELETE\n        GUILD_UPDATE\n        GUILD_BAN_ADD\n        GUILD_BAN_REMOVE\n        GUILD_EMOJIS_UPDATE\n        *GUILD_INTEGRATIONS_UPDATE\n        GUILD_MEMBER_ADD\n        GUILD_MEMBER_REMOVE\n        GUILD_MEMBER_UPDATE\n        GUILD_MEMBERS_CHUNK\n        GUILD_ROLE_CREATE\n        GUILD_ROLE_UPDATE\n        GUILD_ROLE_DELETE\n        CHANNEL_CREATE\n        CHANNEL_DELETE\n        CHANNEL_UPDATE\n        CHANNEL_PINS_UPDATE\n        PRESENCE_UPDATE\n        *PRESENCES_REPLACE\n        USER_UPDATE\n        USER_NOTE_UPDATE\n        USER_SETTINGS_UPDATE\n        VOICE_STATE_UPDATE\n        TYPING_START\n        MESSAGE_CREATE\n        MESSAGE_UPDATE\n        MESSAGE_DELETE\n        MESSAGE_DELETE_BULK\n        MESSAGE_REACTION_ADD\n        MESSAGE_REACTION_REMOVE\n        MESSAGE_REACTION_REMOVE_ALL\n        VOICE_SERVER_UPDATE\n        GUILD_SYNC\n        RELATIONSHIP_ADD\n        RELATIONSHIP_REMOVE\n        * event that hasn\'t been added\n        */\n        //TODO: use references, using them now will break other\'s code\n        virtual void onReady             (Ready              readyData  );\n        virtual void onResumed           (                              );\n        virtual void onDeleteServer      (UnavailableServer server      );\n        virtual void onEditServer        (Server            server      );\n        virtual void onBan               (Snowflake<Server> serverID, User user);\n        virtual void onUnban             (Snowflake<Server> serverID, User user);\n        virtual void onMember            (Snowflake<Server> serverID, ServerMember member);\n        virtual void onRemoveMember      (Snowflake<Server> serverID, User user);\n        virtual void onEditMember        (Snowflake<Server> serverID, User user, std::vector<Snowflake<Role>> roles, std::string nick);\n        virtual void onRole              (Snowflake<Server> serverID, Role role);\n        virtual void onDeleteRole        (Snowflake<Server> serverID, Snowflake<Role> roleID);\n        virtual void onEditRole          (Snowflake<Server> serverID, Role role);\n        virtual void onEditEmojis        (Snowflake<Server> serverID, std::vector<Emoji> emojis);\n        virtual void onMemberChunk       (ServerMembersChunk memberChunk);\n        virtual void onDeleteChannel     (Channel            channel    );\n        virtual void onEditChannel       (Channel            channel    );\n        virtual void onPinMessage        (Snowflake<Channel> channelID, std::string lastPinTimestamp);\n        virtual void onThread            (Channel            channel    ) {}\n        virtual void onThreadUpdate      (Channel            channel    ) {}\n        virtual void onDeleteThread      (Channel            channel    ) {}\n        virtual void onThreadListSync    (ThreadListSync     sync       ) {}\n        virtual void onEditThreadMember  (ThreadMember member, Snowflake<Server> serverID) {}\n        virtual void onEditThreadMembers (ThreadMembersUpdate update    ) {}\n        virtual void onPresenceUpdate    (PresenceUpdate     presenseUpdate);\n        virtual void onEditUser          (User               user       );\n        virtual void onEditUserSettings  (const json::Value& jsonMessage);\n        virtual void onEditVoiceState    (VoiceState&        state      );\n        virtual void onTyping            (Snowflake<Channel> channelID, Snowflake<User> userID, time_t timestamp);\n        virtual void onDeleteMessages    (Snowflake<Channel> channelID, std::vector<Snowflake<Message>> messages);\n        virtual void onEditMessage       (MessageRevisions   revisioins );\n        virtual void onEditVoiceServer   (VoiceServerUpdate& update     );\n        virtual void onReaction          (Snowflake<User> userID, Snowflake<Channel> channelID, Snowflake<Message> messageID, Emoji emoji);\n        virtual void onDeleteReaction    (Snowflake<User> userID, Snowflake<Channel> channelID, Snowflake<Message> messageID, Emoji emoji);\n        virtual void onDeleteAllReaction (Snowflake<Server> serverID, Snowflake<Channel> channelID, Snowflake<Message> messageID);\n        virtual void onMessage           (Message            message    );\n        virtual void onServer            (Server             server     );\n        virtual void onChannel           (Channel            channel    );\n        virtual void onInteraction       (Interaction        interaction) {}\n        virtual void onAppCommand        (AppCommand         appCommand ) {}\n        virtual void onEditAppCommand    (AppCommand         appCommand ) {}\n        virtual void onDeleteAppCommand  (AppCommand         appCommand ) {}\n        virtual void onStageInstance     (StageInstance      instance   ) {}\n        virtual void onDeleteStageInstance(StageInstance      instance   ) {}\n        virtual void onEditStageInstance (StageInstance      instance   ) {}\n        virtual void onUnknownEvent      (std::string name, const json::Value& data); //for extending old library versions\n        virtual void onDispatch          (const json::Value& t, json::Value& d) {}\n\n        //websocket stuff\n        virtual void onHeartbeat();\n        virtual void onHeartbeatAck();\n        virtual void onInvaldSession();\n        virtual void onDisconnect();\n        virtual void onResume();\n\n        virtual void onQuit();\n        virtual void onRestart() {}\n        virtual void onResponse(Response response);\n        virtual void sleep(const unsigned int milliseconds);  //Deprecated, use schedule instead\n        virtual void fileRead(const char* path, std::string*const file);\n        virtual void tick(float deltaTime);\n        virtual void onError(ErrorCode errorCode, const std::string errorMessage);\n\n        /*do not use or overwrite the protected values below,\n        unless you know what you are doing*/\n        void processMessage(const std::string &message) override;\n        void processMessage(const WebSocketMessage message) override;\n        void processCloseCode(const int16_t code) override;\n        void heartbeat();\n        void sendHeartbeat() {\n            const auto heartbeat = generateHeatbeat(lastSReceived);\n            const nonstd::string_view message(heartbeat.buffer.data(), heartbeat.length);\n            //to do switch sendL to string_view\n            sendL(std::string{ message.data(), message.length() });\n            wasHeartbeatAcked = false;\n            onHeartbeat();\n        }\n        void resetHeartbeatValues();\n        inline std::string getToken() { return *token.get(); }\n        inline void setToken(const std::string& value) { token = std::unique_ptr<std::string>(new std::string(value)); }\n        void start(const std::string _token, const char maxNumOfThreads = DEFAULT_THREADS, int _shardID = 0, int _shardCount = 0);\n        inline void connect() {\n            postTask([this]() {\n                getTheGateway();\n                connect(theGateway, this, connection);\n            });\n        }\n        virtual bool connect(\n            const std::string & /*uri*/,                    //IN\n            GenericMessageReceiver* /*messageProcessor*/,   //IN  When a message is receved, this will process it\n            WebsocketConnection& /*connection*/             //OUT data needed in order to send a message. nullptr by default\n        ) { return false; }\n        void handleFailToConnect() override { reconnect(); }\n        virtual void send(std::string /*message*/, WebsocketConnection& /*connection*/) {}\n        virtual void disconnect(unsigned int /*code*/, const std::string /*reason*/, WebsocketConnection& /*connection*/) {}\n        void reconnect(const unsigned int status = 4900);\n        virtual void stopClient() {}\n        //the next 3 functions are part of BaseDiscordClient because VoiceConnection is a private nested class\n        inline void initialize(GenericMessageReceiver*& messageProcessor) const {\n            messageProcessor->initialize();\n        }\n        inline void processMessage(GenericMessageReceiver*& messageProcessor, const std::string& message) const {\n            messageProcessor->processMessage(message);\n        }\n        inline void processCloseCode(GenericMessageReceiver*& messageProcessor, const int16_t& code) const {\n            messageProcessor->processCloseCode(code);\n        }\n        virtual void runAsync();\n        virtual const time_t getEpochTimeMillisecond();\n        virtual const double getEpochTimeSecond();\n\n    private:\n        using GenericMessageReceiver::initialize;\n\n        int heartbeatInterval = 0;\n        int64_t lastHeartbeat = 0;\n        int lastSReceived = 0;\n        bool wasHeartbeatAcked = true;\n        std::unique_ptr<GenericScheduleHandler> scheduleHandler = nullptr;\n        Timer heart;\n\n        enum OPCode {\n            DISPATCH              = 0,  //dispatches an event\n            HEARTHBEAT            = 1,  //used for ping checking\n            IDENTIFY              = 2,  //used for client handshake\n            STATUS_UPDATE         = 3,  //used to update the client status\n            VOICE_STATE_UPDATE    = 4,  //used to join / move / leave voice channels\n            VOICE_SERVER_PING     = 5,  //used for voice ping checking\n            RESUME                = 6,  //used to resume a closed connection\n            RECONNECT             = 7,  //used to tell clients to reconnect to the gateway\n            REQUEST_GUILD_MEMBERS = 8,  //used to request guild members\n            INVALID_SESSION       = 9,  //used to notify client they have an invalid session id\n            HELLO                 = 10, //sent immediately after connecting, contains heartbeat and server debug information\n            HEARTBEAT_ACK         = 11, //sent immediately following a client heartbeat that was received\n        };\n\n        std::unique_ptr<std::string> token;     //stored in a unique_ptr so that you can\'t see it in the debugger\n        std::string sessionID;  //TODO: replace this with a Ready object\n        int shardID = 0;\n        int shardCount = 0;\n        Intent intents;\n        bool intentsIsSet = false;\n        Snowflake<User> userID;\n        void getTheGateway();\n        std::string theGateway;\n        bool ready = false;\n        bool quiting = false;\n        bool bot = true;\n        void sendIdentity();\n        void sendResume();\n        void quit(bool isRestarting, bool isDisconnected = false);\n        void restart();\n        void disconnectWebsocket(unsigned int code, const std::string reason = "");\n        bool sendL(std::string message);    //the L stands for Limited\n        void handleDispatchEvent(const json::Value& t, json::Value& d);\n        int64_t nextHalfMin = 0;\n        std::mutex connectionMutex;\n        bool isCurrentlyWaitingToReconnect = false;\n        void stopReconnecting();\n\n        //Cache\n        std::shared_ptr<ServerCache> serverCache;\n\n        //rate limiting\n        int8_t messagesRemaining = 0;\n        RateLimiter<BaseDiscordClient> rateLimiter;\n\n        //error handling\n        void setError(int errorCode);\n\n        //for endpoint functions\n        const std::string getEditPositionString(const std::vector<std::pair<std::string, uint64_t>>& positions);\n\n        //\n        //voice\n        //\n        std::forward_list<VoiceConnection> voiceConnections;\n        std::forward_list<VoiceContext> voiceContexts;\n        std::forward_list<VoiceContext*> waitingVoiceContexts;\n#ifdef SLEEPY_VOICE_ENABLED\n        void connectToVoiceIfReady(VoiceContext& context);\n        void removeVoiceConnectionAndContext(VoiceConnection& connection);\n#endif\n\n        //compression\n        std::unique_ptr<GenericCompression> compressionHandler;\n        int8_t useTrasportConnection = static_cast<int8_t>(-1); //-1 for not set\n\n        template<class Options, class Allocator>\n        typename std::enable_if<std::is_same<std::nullptr_t, std::remove_cv_t<Options>>::value, void>::type\n            createOptionsValue(\n                rapidjson::Document& doc, Allocator& allocator, Options& options\n        ) {\n            return;\n        }\n\n        template<class Options, class Allocator>\n        typename std::enable_if<!std::is_pointer<Options>::value && !std::is_same<const Options, const SleepyDiscord::AppCommand::EmptyOptions>::value, void>::type\n            createOptionsValue(rapidjson::Document& doc, Allocator& allocator, Options& options) {\n            if (!options.empty()) {\n                rapidjson::Value arr{ rapidjson::Type::kArrayType };\n                for (auto& option : options) {\n                    arr.PushBack(json::toJSON(option, allocator), allocator);\n                }\n                doc.AddMember("options", arr, allocator);\n            }\n        }\n\n        template<class Options>\n        std::string createApplicationCommandBody(std::string name, std::string description, Options& options, const bool defaultPermission, AppCommand::Type type, const bool allOptional = false) {\n            rapidjson::Document doc;\n            doc.SetObject();\n            auto& allocator = doc.GetAllocator();\n            if (!allOptional || !name.empty())\n                doc.AddMember("name", rapidjson::Value::StringRefType{ name.c_str(), name.length() }, allocator);\n            if (!allOptional || !description.empty())\n                doc.AddMember("description", rapidjson::Value::StringRefType{ description.c_str(), description.length() }, allocator);\n            if (!allOptional || defaultPermission != true) //default is true\n                doc.AddMember("default_permission", defaultPermission, allocator);\n            if (type != AppCommand::Type::NONE)\n                doc.AddMember("type", static_cast<GetEnumBaseType<AppCommand::Type>::Value>(type), allocator);\n            createOptionsValue<Options>(doc, allocator, options);\n            return json::stringify(doc);\n        }\n\n        template<class Callback>\n        void findServerInCache(Snowflake<Server>& serverID, Callback onSuccessCallback) {\n            if (serverCache) {\n                ServerCache::iterator server = serverCache->findServer(serverID);\n                if (server != static_cast<const ServerCache::iterator>(serverCache->end())) {\n                    onSuccessCallback(server);\n                }\n            }\n        }\n\n        template<class Callback>\n        void accessServerFromCache(Snowflake<Server>& serverID, Callback callback) {\n            findServerInCache(serverID, [callback](ServerCache::iterator& found) {\n                callback(*found);\n            });\n        }\n\n        template<class Container, class Callback>\n        void accessContainerFromCache(\n            Snowflake<Server>& serverID, Container Server::* container, Callback callback\n        ) {\n            accessServerFromCache(serverID, [callback, container](Server& server) {\n                callback(server, server.*(container));\n            });\n        }\n\n        template<class Container>\n        void appendObjectToCache(\n            Snowflake<Server>& serverID, Container Server::* container, typename Container::value_type& object\n        ) {\n            accessContainerFromCache(serverID, container,\n                [object](Server&, Container& found) {\n                    found.push_front(object);\n                }\n            );\n        }\n\n        template<class Type, class Container, class Callback>\n        void accessIteratorFromCache (\n            Snowflake<Server>& serverID, Container Server::* container, Type ID, Callback callback\n        ) {\n            accessContainerFromCache(serverID, container,\n                [callback, ID](Server& server, Container& foundContainter) {\n                    auto found = ID.findObject(foundContainter);\n                    if (found != foundContainter.end()) {\n                        callback(server, found);\n                    }\n                }\n            );\n        }\n\n        template<class Type, class Container, class Callback>\n        void accessObjectFromCache(\n            Snowflake<Server> serverID, Container Server::* container, Type ID, Callback callback\n        ) {\n            accessIteratorFromCache(serverID, container, ID,\n                [callback] (Server& server, typename Container::iterator& iterator) {\n                    callback(server, *iterator);\n                }\n            );\n        }\n\n        template<class Type, class Container>\n        void eraseObjectFromCache(\n            Snowflake<Server> serverID, Container Server::* container, Type ID\n        ) {\n            accessIteratorFromCache(serverID, container, ID,\n                [container](Server& server, typename Container::iterator& found) {\n                    (server.*(container)).erase(found);\n                }\n            );\n        }\n\n        //The number 10 comes from the largest unsigned int being 10 digits long\n        using DBuffer = std::array<char, 10>;\n        //The number 18 comes from 1 plus the length of {\\"op\\":1,\\"d\\":}\n        using HeartbeatBuffer = std::array<char, 18 + std::tuple_size<DBuffer>::value>;\n\n        struct Heartbeat {\n            HeartbeatBuffer buffer;\n            std::size_t length;\n        };\n\n        //no reason for this to be so optimized because I just felt like it one day\n#ifdef __cpp_lib_array_constexpr\n        constexpr\n#endif\n            Heartbeat generateHeatbeat(const unsigned int lastSReceived) {\n            DBuffer dBuffer{};\n            //can\'t find a number to std array so a custom one is made here\n            auto reverseNext = dBuffer.end();\n            auto trunc = lastSReceived;\n            do {\n                reverseNext -= 1;\n                *reverseNext = \'0\' + (trunc % 10);\n                trunc /= 10;\n            } while (trunc != 0);\n\n            const nonstd::string_view d{ &(*reverseNext),\n                std::size_t(dBuffer.end() - reverseNext) };\n\n#define SLEEPY_HEARTBEAT_START "{"\\\n                "\\"op\\":1,"\\\n                "\\"d\\":"\n\n#define SLEEPY_HEARTBEAT_END "}"\n\n            constexpr auto startBuffer = SLEEPY_HEARTBEAT_START;\n            constexpr auto endBuffer = SLEEPY_HEARTBEAT_END;\n            constexpr auto startLength = sizeof(SLEEPY_HEARTBEAT_START) - 1;\n            //this works because char is one btye\n            constexpr auto endLength = sizeof(SLEEPY_HEARTBEAT_END) - 1;\n            constexpr auto start = nonstd::string_view{ startBuffer, startLength };\n            constexpr auto end = nonstd::string_view{ endBuffer, endLength };\n\n\n            const std::array<nonstd::string_view, 3> toConcat{ {\n                start, d, end\n            } };\n\n            Heartbeat heartbeat = {};\n            HeartbeatBuffer& heartbeatBuffer = heartbeat.buffer;\n            std::size_t& index = heartbeat.length;\n            for (const auto& source : toConcat)\n            {\n                auto dest = heartbeatBuffer.begin() + index;\n\n                //memcpy not avaiable at compile time\n                for (std::size_t index = 0; index < source.length(); index += 1) {\n                    dest[index] = source[index];\n                }\n                index += source.length();\n            }\n\n            return heartbeat;\n        }\n    };\n\n    template<> struct BaseDiscordClient::RequestModeType<Async> : BaseDiscordClient::RawRequestModeTypeHelper<Async, void> {\n        RequestModeRequestDefine {\n            client.requestAsync<ParmType, Callback>(method, path, callback, jsonParameters, multipartParameters);\n        }\n    };\n    template<> struct BaseDiscordClient::RequestModeType<Sync>  : BaseDiscordClient::RawRequestModeTypeHelper<Sync , Request> {\n        RequestModeRequestDefine {\n            return client.requestSync(method, path, callback, jsonParameters, multipartParameters);\n        }\n    };\n\n}\n\n//locks away functions that users shouldn\'t be using\n#define SLEEPY_LOCK_CLIENT_FUNCTIONS private:                                  \\\n                                     using BaseDiscordClient::processMessage;  \\\n                                     using BaseDiscordClient::start;           \\\n                                     using BaseDiscordClient::sendHeartbeat;   \\\n                                     using BaseDiscordClient::initialize;      \\\n                                     using BaseDiscordClient::processCloseCode;\\\n                                     using BaseDiscordClient::reconnect;       \\\n                                     using BaseDiscordClient::stopClient;      \\\n\n//This comment stops a warning\n')),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Updated on 28 October 2023 at 21:20:08 UTC"))}u.isMDXComponent=!0}}]);