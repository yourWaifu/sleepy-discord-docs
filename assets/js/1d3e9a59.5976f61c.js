"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[8730],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return u}});var a=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var p=a.createContext({}),i=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=i(e.components);return a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=i(t),u=s,N=m["".concat(p,".").concat(u)]||m[u]||d[u]||r;return t?a.createElement(N,o(o({ref:n},c),{},{components:t})):a.createElement(N,o({ref:n},c))}));function u(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,o=new Array(r);o[0]=m;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:s,o[1]=l;for(var i=2;i<r;i++)o[i]=t[i];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},225:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return i},toc:function(){return c},default:function(){return m}});var a=t(3117),s=t(102),r=(t(7294),t(3905)),o=["components"],l={title:"include/sleepy_discord/message.h"},p=void 0,i={unversionedId:"reference/Files/message_8h",id:"reference/Files/message_8h",title:"include/sleepy_discord/message.h",description:"Namespaces",source:"@site/docs/reference/Files/message_8h.md",sourceDirName:"reference/Files",slug:"/reference/Files/message_8h",permalink:"/sleepy-discord/docs/reference/Files/message_8h",tags:[],version:"current",frontMatter:{title:"include/sleepy_discord/message.h"},sidebar:"Reference",previous:{title:"sleepy_discord/message.cpp",permalink:"/sleepy-discord/docs/reference/Files/message_8cpp"},next:{title:"include/sleepy_discord/message_receiver.h",permalink:"/sleepy-discord/docs/reference/Files/message__receiver_8h"}},c=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Classes",id:"classes",children:[],level:2},{value:"Types",id:"types",children:[],level:2},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum InteractionType",id:"enum-interactiontype",children:[],level:3},{value:"enum ComponentType",id:"enum-componenttype",children:[],level:3},{value:"enum ButtonStyle",id:"enum-buttonstyle",children:[],level:3},{value:"enum TextInputStyle",id:"enum-textinputstyle",children:[],level:3},{value:"enum MentionReplierFlag",id:"enum-mentionreplierflag",children:[],level:3}],level:2},{value:"Source code",id:"source-code",children:[],level:2}],d={toc:c};function m(e){var n=e.components,t=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"namespaces"},"Namespaces"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord_1_1json"},"SleepyDiscord::json")))))),(0,r.kt)("h2",{id:"classes"},"Classes"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_emoji"},"SleepyDiscord::Emoji")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_reaction"},"SleepyDiscord::Reaction")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_component"},"SleepyDiscord::BaseComponent")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_raw_component"},"SleepyDiscord::RawComponent")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_component_temp"},"SleepyDiscord::ComponentTemp")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_action_row"},"SleepyDiscord::ActionRow")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_button"},"SleepyDiscord::Button")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_select_menu"},"SleepyDiscord::SelectMenu")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_select_menu_1_1_option"},"SleepyDiscord::SelectMenu::Option")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_text_inputs"},"SleepyDiscord::TextInputs")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01std_1_1shared__ptr_3_01_base_component_01_4_01_4"},"SleepyDiscord::json::ClassTypeHelper< std::shared_ptr< BaseComponent > >")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_sticker_pack"},"SleepyDiscord::StickerPack")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_sticker"},"SleepyDiscord::Sticker")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_message_reference"},"SleepyDiscord::MessageReference")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_message"},"SleepyDiscord::Message")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_message_1_1_interaction"},"SleepyDiscord::Message::Interaction")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_message_revisions"},"SleepyDiscord::MessageRevisions")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_allow_mentions_parse_helper"},"SleepyDiscord::AllowMentionsParseHelper")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_allowed_mentions"},"SleepyDiscord::AllowedMentions")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_get_default_3_01_allowed_mentions_1_1_mention_replier_flag_01_4"},"SleepyDiscord::GetDefault< AllowedMentions::MentionReplierFlag >")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_get_enum_base_type_3_01_allowed_mentions_1_1_mention_replier_flag_01_4"},"SleepyDiscord::GetEnumBaseType< AllowedMentions::MentionReplierFlag >")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_message_params"},"SleepyDiscord::MessageParams")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_send_message_params"},"SleepyDiscord::SendMessageParams")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_edit_message_params"},"SleepyDiscord::EditMessageParams")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_edit_webhook_params"},"SleepyDiscord::BaseEditWebhookParams")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_edit_webhook_params"},"SleepyDiscord::EditWebhookParams")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_base_web_hook_params"},"SleepyDiscord::BaseWebHookParams")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"struct"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_web_hook_params"},"SleepyDiscord::WebHookParams")))))),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum int"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/message_8h#enum-interactiontype"},"InteractionType"))," { NONE = 0, Ping = 1, ApplicationCommand = 2, MessageComponent = 3, ApplicationCommandAutocomplete = 4, ModalSubmit = 5}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/message_8h#enum-componenttype"},"ComponentType"))," { NONE = 0, ActionRow = 1, Button = 2, SelectMenu = 3, TextInputs = 4}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/message_8h#enum-buttonstyle"},"ButtonStyle"))," { NONE = 0, Primary = 1, Secondary = 2, Success = 3, Danger = 4, Link = 5, DefaultStyle = NONE}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/message_8h#enum-textinputstyle"},"TextInputStyle"))," { NONE = 0, Short = 1, Paragraph = 2, DefaultStyle = NONE}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/message_8h#enum-mentionreplierflag"},"MentionReplierFlag"))," { NotSet = -2, DoNotMentionReply = false, MentionReply = true}")))),(0,r.kt)("h2",{id:"types-documentation"},"Types Documentation"),(0,r.kt)("h3",{id:"enum-interactiontype"},"enum InteractionType"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NONE"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ping"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ApplicationCommand"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MessageComponent"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ApplicationCommandAutocomplete"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ModalSubmit"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"enum-componenttype"},"enum ComponentType"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NONE"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ActionRow"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Button"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SelectMenu"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TextInputs"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"enum-buttonstyle"},"enum ButtonStyle"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NONE"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Primary"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Secondary"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Success"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Danger"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Link"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DefaultStyle"),(0,r.kt)("td",{parentName:"tr",align:null},"NONE"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"enum-textinputstyle"},"enum TextInputStyle"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NONE"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Short"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Paragraph"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DefaultStyle"),(0,r.kt)("td",{parentName:"tr",align:null},"NONE"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"enum-mentionreplierflag"},"enum MentionReplierFlag"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NotSet"),(0,r.kt)("td",{parentName:"tr",align:null},"-2"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DoNotMentionReply"),(0,r.kt)("td",{parentName:"tr",align:null},"false"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MentionReply"),(0,r.kt)("td",{parentName:"tr",align:null},"true"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h2",{id:"source-code"},"Source code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <tuple>\n#include <memory>\n#include "user.h"\n#include "attachment.h"\n#include "embed.h"\n#include "permissions.h"\n#include "webhook.h"\n#include "discord_object_interface.h"\n#include "snowflake.h"\n#include "channel.h"\n#include "nonstd/optional.hpp"\n\n// <--- means to add later\n\nnamespace SleepyDiscord {\n    //declear here since message.h is need for slash commands and this enum is needed for messages\n    enum class InteractionType : int {\n        NONE = 0, //made up type\n        Ping = 1,\n        ApplicationCommand = 2,\n        MessageComponent = 3,\n        ApplicationCommandAutocomplete = 4,\n        ModalSubmit = 5\n    };\n\n    struct Emoji : public IdentifiableDiscordObject<Emoji> {\n    public:\n        ~Emoji();\n        Emoji() = default;\n        //Emoji(const std::string* rawJson);\n        Emoji(const json::Value & rawJSON);\n        Emoji(const nonstd::string_view& json) :\n            Emoji(json::fromJSON<Emoji>(json)) {}\n        //Emoji(const json::Values values);\n        std::string name;\n        std::vector<Snowflake<Role>> roles;\n        User user;  //optional\n        bool requireColons = false;\n        bool managed = false;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Emoji::ID           , "id"            , json::NULLABLE_FIELD),\n                json::pair                           (&Emoji::name         , "name"          , json::NULLABLE_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Emoji::roles        , "roles"         , json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::user         , "user"          , json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::requireColons, "require_colons", json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::managed      , "managed"       , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n    \n    struct Reaction : public DiscordObject {\n    public:\n        Reaction() = default;\n        ~Reaction();\n        //Reaction(const std::string * rawJson);\n        Reaction(const json::Value & rawJSON);\n        Reaction(const nonstd::string_view& json) :\n            Reaction(json::fromJSON<Reaction>(json)) {}\n        //Reaction(const json::Values values);\n        int count = 0;\n        bool me = false;\n        Emoji emoji;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&Reaction::count, "count", json::REQUIRIED_FIELD),\n                json::pair(&Reaction::me   , "me"   , json::REQUIRIED_FIELD),\n                json::pair(&Reaction::emoji, "emoji", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    enum class ComponentType {\n        NONE = 0, //made up by the library\n        ActionRow = 1,\n        Button = 2,\n        SelectMenu = 3,\n        TextInputs = 4,\n    };\n\n    struct BaseComponent : public DiscordObject {\n        using Type = ComponentType;\n        BaseComponent() = delete;\n        BaseComponent(Type _type) : type(_type) {}\n        ~BaseComponent() = default;\n\n        inline const ComponentType getType() const { return type; }\n\n    protected:\n        Type type;\n    };\n\n    struct RawComponent : public BaseComponent {\n        using JSONTypeHelper = json::ClassTypeHelper<json::Value>;\n\n        RawComponent(BaseComponent base, json::Value& rawJSON) : BaseComponent(std::move(base)) {\n            data = JSONTypeHelper::toType(rawJSON);\n        }\n        RawComponent(json::Value& rawJSON) : RawComponent(BaseComponent{static_cast<ComponentType>(rawJSON["type"].GetInt())}, rawJSON) {}\n        RawComponent(const nonstd::string_view& json) :\n            RawComponent(json::fromJSON<RawComponent>(json)) {}\n        RawComponent(const RawComponent& origin) : BaseComponent(origin.type), data(json::copy(origin.data)) {}\n\n        inline json::Value serialize(typename json::Value::AllocatorType& alloc) const {\n            return JSONTypeHelper::fromType(data, alloc);\n        }\n\n        inline const bool empty() const { return JSONTypeHelper::empty(data); }\n\n        static inline const bool isType(const typename json::Value& value) {\n            return value.IsObject() && value.FindMember("type") != value.MemberEnd();\n        }\n\n        json::Value data;\n    };\n\n    template<class Child>\n    struct ComponentTemp : public BaseComponent {\n        ComponentTemp() : BaseComponent(Child::componentType) {}\n        ~ComponentTemp() = default;\n\n        inline operator json::Value() {\n            return json::toJSON(static_cast<Child&>(*this));\n        }\n\n        inline operator RawComponent() {\n            return RawComponent{ Child::componentType, operator json::Value() };\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair<json::EnumTypeHelper>(&Child::type, "type", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ActionRow : public ComponentTemp<ActionRow> {\n        ActionRow() = default;\n        ~ActionRow() = default;\n        ActionRow(json::Value& json);\n        ActionRow(const nonstd::string_view& json) :\n            ActionRow(json::fromJSON<ActionRow>(json)) {}\n        static const ComponentType componentType = ComponentType::ActionRow;\n\n        std::vector<std::shared_ptr<BaseComponent>> components;\n\n        JSONStructStart\n            std::tuple_cat(\n                ComponentTemp<ActionRow>::JSONStruct,\n                std::make_tuple(\n                    json::pair<json::ContainerTypeHelper>(&ActionRow::components, "components", json::OPTIONAL_FIELD)\n                )\n            );\n        JSONStructEnd\n    };\n\n    enum class ButtonStyle {\n        NONE = 0,\n        Primary = 1,\n        Secondary = 2,\n        Success = 3,\n        Danger = 4,\n        Link = 5,\n        DefaultStyle = NONE, //made up for the library to handle null style\n    };\n\n    struct Button : public ComponentTemp<Button> {\n        Button() = default;\n        ~Button() = default;\n        Button(const json::Value& json);\n        Button(const nonstd::string_view& json) :\n            Button(json::fromJSON<Button>(json)) {}\n        static const ComponentType componentType = ComponentType::Button;\n\n        ButtonStyle style;\n        std::string label;\n        Emoji emoji;\n        std::string customID;\n        std::string url;\n        bool disabled = false;\n\n        JSONStructStart\n            std::tuple_cat(\n                ComponentTemp<Button>::JSONStruct,\n                std::make_tuple(\n                    json::pair<json::EnumTypeHelper>(&Button::style   , "style"    , json::REQUIRIED_FIELD),\n                    json::pair                      (&Button::label   , "label"    , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Button::emoji   , "emoji"    , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Button::customID, "custom_id", json::OPTIONAL_FIELD ),\n                    json::pair                      (&Button::url     , "url"      , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Button::disabled, "disabled" , json::OPTIONAL_FIELD )\n                )\n            );\n        JSONStructEnd\n    };\n\n    struct SelectMenu : public ComponentTemp<SelectMenu> {\n        SelectMenu() = default;\n        ~SelectMenu() = default;\n        SelectMenu(const json::Value& json);\n        SelectMenu(const nonstd::string_view& json) :\n            SelectMenu(json::fromJSON<SelectMenu>(json)) {}\n        static const ComponentType componentType = ComponentType::SelectMenu;\n\n        struct Option : public DiscordObject {\n            Option() = default;\n            ~Option() = default;\n            Option(const json::Value & rawJSON);\n            Option(const nonstd::string_view& json) :\n                SelectMenu::Option(json::fromJSON<SelectMenu::Option>(json)) {}\n\n            std::string label;\n            std::string value;\n            std::string description;\n            Emoji emoji;\n            bool isDefault = false;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair(&Option::label      , "label"      , json::REQUIRIED_FIELD),\n                    json::pair(&Option::value      , "value"      , json::REQUIRIED_FIELD),\n                    json::pair(&Option::description, "description", json::OPTIONAL_FIELD ),\n                    json::pair(&Option::emoji      , "emoji"      , json::OPTIONAL_FIELD ),\n                    json::pair(&Option::isDefault  , "default"    , json::OPTIONAL_FIELD )\n                );\n            JSONStructEnd\n        };\n\n        std::string customID;\n        std::vector<Option> options;\n        std::string placeholder;\n        int minValues = 1;\n        int maxValues = 1;\n        bool disabled = false;\n\n        JSONStructStart\n            std::tuple_cat(\n                ComponentTemp<SelectMenu>::JSONStruct,\n                std::make_tuple(\n                    json::pair                           (&SelectMenu::customID   , "custom_id"  , json::REQUIRIED_FIELD),\n                    json::pair<json::ContainerTypeHelper>(&SelectMenu::options    , "options"    , json::REQUIRIED_FIELD),\n                    json::pair                           (&SelectMenu::placeholder, "placeholder", json::OPTIONAL_FIELD ),\n                    json::pair<                        1>(&SelectMenu::minValues  , "min_values" , json::OPTIONAL_FIELD ),\n                    json::pair<                        1>(&SelectMenu::maxValues  , "max_values" , json::OPTIONAL_FIELD ),\n                    json::pair                           (&SelectMenu::disabled   , "disabled"   , json::OPTIONAL_FIELD )\n                )\n            );\n        JSONStructEnd\n    };\n\n    enum class TextInputStyle {\n        NONE = 0,\n        Short = 1,\n        Paragraph = 2,\n        DefaultStyle = NONE, //made up for the library to handle null style\n    };\n\n    struct TextInputs : public ComponentTemp<TextInputs> {\n        TextInputs() = default;\n        ~TextInputs() = default;\n        TextInputs(const json::Value& json);\n        TextInputs(const nonstd::string_view& json) :\n            TextInputs(json::fromJSON<TextInputs>(json)) {}\n        static const ComponentType componentType = ComponentType::TextInputs;\n\n        using Style = TextInputStyle;\n\n        std::string customID;\n        TextInputStyle style;\n        std::string label;\n        int minLength = -1;\n        int maxLength = -1;\n        bool required = false;\n        std::string value;\n        std::string placeholder;\n\n        JSONStructStart\n            std::tuple_cat(\n                ComponentTemp<TextInputs>::JSONStruct,\n                std::make_tuple(\n                    json::pair                      (&TextInputs::customID   , "custom_id"  , json::REQUIRIED_FIELD),\n                    json::pair<json::EnumTypeHelper>(&TextInputs::style      , "style"      , json::OPTIONAL_FIELD ),\n                    json::pair                      (&TextInputs::label      , "label"      , json::OPTIONAL_FIELD ),\n                    json::pair<                  -1>(&TextInputs::minLength  , "min_length" , json::OPTIONAL_FIELD ),\n                    json::pair<                  -1>(&TextInputs::maxLength  , "max_length" , json::OPTIONAL_FIELD ),\n                    json::pair                      (&TextInputs::required   , "required"   , json::OPTIONAL_FIELD ),\n                    json::pair                      (&TextInputs::value      , "value"      , json::OPTIONAL_FIELD ),\n                    json::pair                      (&TextInputs::placeholder, "placeholder", json::OPTIONAL_FIELD )\n                )\n            );\n        JSONStructEnd\n    };\n\n    namespace json {\n        template<>\n        struct ClassTypeHelper<std::shared_ptr<BaseComponent>> {\n            using Base = BaseComponent;\n            using Type = std::shared_ptr<BaseComponent>;\n\n            static inline Type toType(json::Value& value) {\n                const ComponentType type = static_cast<ComponentType>(value["type"].GetInt());\n                switch (type) {\n                default:\n                    return std::make_shared<RawComponent>(Base{ type }, value);\n                case ComponentType::ActionRow:\n                    return std::make_shared<ActionRow>(value);\n                case ComponentType::Button:\n                    return std::make_shared<Button>(value);\n                case ComponentType::SelectMenu:\n                    return std::make_shared<SelectMenu>(value);\n                case ComponentType::TextInputs:\n                    return std::make_shared<TextInputs>(value);\n                }\n            }\n            static inline json::Value fromType(const Type& value, json::Value::AllocatorType& allocator) {\n                if (!value)\n                    return json::Value{};\n\n                const ComponentType type = value->getType();\n                switch (type) {\n                default:\n                    return std::static_pointer_cast<RawComponent>(value)->serialize(allocator);\n                case ComponentType::ActionRow:\n                    return json::ClassTypeHelper<ActionRow>::fromType(*std::static_pointer_cast<ActionRow>(value), allocator);\n                case ComponentType::Button:\n                    return json::ClassTypeHelper<Button>::fromType(*std::static_pointer_cast<Button>(value), allocator);\n                case ComponentType::SelectMenu:\n                    return json::ClassTypeHelper<SelectMenu>::fromType(*std::static_pointer_cast<SelectMenu>(value), allocator);\n                case ComponentType::TextInputs:\n                    return json::ClassTypeHelper<TextInputs>::fromType(*std::static_pointer_cast<TextInputs>(value), allocator);\n                }\n            }\n            static inline bool empty(const Type& value) {\n                return json::SmartPtrTypeHelper<std::shared_ptr<BaseComponent>, json::ClassTypeHelper>::empty(value);\n            }\n            static inline bool isType(const json::Value& value) {\n                return value.IsObject() && value.FindMember("type") != value.MemberEnd();\n            }\n        };\n    }\n\n    struct StickerPack : public IdentifiableDiscordObject<StickerPack> {\n    public:\n        StickerPack() = default;\n        ~StickerPack();\n        StickerPack(const json::Value & json);\n        StickerPack(const nonstd::string_view& json) :\n            StickerPack(json::fromJSON<StickerPack>(json)) {}\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&StickerPack::ID, "id", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct Sticker : public IdentifiableDiscordObject<Sticker> {\n    public:\n        Sticker() = default;\n        ~Sticker();\n        Sticker(const json::Value & json);\n        Sticker(const nonstd::string_view & json);\n        Snowflake<StickerPack> packID;\n        std::string name;\n        std::string description;\n        std::string tags;\n        enum class Type : int {\n            NONE = 0,\n            PNG = 1,\n            APNG = 2,\n            LOTTIE = 3\n        } format;\n        \n        JSONStructStart\n            std::make_tuple(\n                json::pair                      (&Sticker::ID             , "id"              , json::REQUIRIED_FIELD),\n                json::pair                      (&Sticker::name           , "name"            , json::OPTIONAL_FIELD ),\n                json::pair                      (&Sticker::description    , "description"     , json::OPTIONAL_FIELD ),\n                json::pair                      (&Sticker::tags           , "tags"            , json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper>(&Sticker::format         , "format_type"     , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    //forward declearion\n    class BaseDiscordClient;\n    struct Server;\n    struct Message;\n\n    struct MessageReference {\n    public:\n        MessageReference() = default;\n        ~MessageReference() = default;\n        MessageReference(const json::Value& json);\n        MessageReference(const nonstd::string_view& json) :\n            MessageReference(json::fromJSON<MessageReference>(json)) {}\n        MessageReference(const Message& message);\n\n        Snowflake<Message> messageID;\n        Snowflake<Channel> channelID;\n        Snowflake<Server> serverID;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&MessageReference::messageID, "message_id", json::OPTIONAL_FIELD),\n                json::pair(&MessageReference::channelID, "channel_id", json::OPTIONAL_FIELD),\n                json::pair(&MessageReference::serverID , "guild_id"  , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n        inline const bool empty() const {\n            return messageID.empty() && channelID.empty() && serverID.empty();\n        }\n    };\n\n    struct Message : public IdentifiableDiscordObject<Message> {\n    public:\n        Message() = default;\n        ~Message() = default;\n        Message(json::Value& json);\n        Message(const nonstd::string_view& json) :\n            Message(json::fromJSON<Message>(json)){}\n        bool startsWith(const std::string& test);\n        std::size_t length();\n        bool isMentioned(Snowflake<User> ID);\n        bool isMentioned(User& _user);\n        Message send(BaseDiscordClient * client);\n        Message reply(BaseDiscordClient * client, std::string message,\n            Embed embed = Embed()\n        );\n\n        Snowflake<Channel> channelID;\n        Snowflake<Server> serverID;\n        User author;\n        ServerMember member;\n        std::string content;\n        std::string timestamp;\n        std::string editedTimestamp;\n        bool tts = false;\n        bool mentionEveryone = false;\n        std::vector<User> mentions;\n        std::vector<Snowflake<User>> mentionRoles;\n        std::vector<Attachment> attachments;\n        std::vector<Embed> embeds;\n        std::vector<Reaction> reactions;\n        bool pinned = false;\n        Snowflake<Webhook> webhookID;\n        enum MessageType {\n            DEFAULT                                =  0,\n            RECIPIENT_ADD                          =  1,\n            RECIPIENT_REMOVE                       =  2,\n            CALL                                   =  3,\n            CHANNEL_NAME_CHANGE                    =  4,\n            CHANNEL_ICON_CHANGE                    =  5,\n            CHANNEL_PINNED_MESSAGE                 =  6,\n            GUILD_MEMBER_JOIN                      =  7,\n            USER_PREMIUM_GUILD_SUBSCRIPTION        =  8,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 =  9,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10,\n            USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11,\n            CHANNEL_FOLLOW_ADD                     = 12,\n            GUILD_DISCOVERY_DISQUALIFIED           = 14,\n            GUILD_DISCOVERY_REQUALIFIED            = 15,\n            REPLY                                  = 19\n        } type = DEFAULT;\n        std::vector<Sticker> stickers;\n        MessageReference messageReference;\n        std::shared_ptr<Message> referencedMessage;\n        enum class Flags {\n            DEFAULT                = 0,\n            CROSSPOSTED            = 1 << 0,\n            IS_CROSSPOST           = 1 << 1,\n            SUPPRESS_EMBEDS        = 1 << 2,\n            SOURCE_MESSAGE_DELETED = 1 << 3,\n            URGENT                 = 1 << 4,\n            EPHEMERAL              = 64\n        } flags = Flags::DEFAULT;\n        //interaction\n        struct Interaction : public IdentifiableDiscordObject<Interaction> {\n        public:\n            Interaction() = default;\n            ~Interaction() = default;\n            Interaction(const json::Value& json);\n            Interaction(const nonstd::string_view& json) :\n                Interaction(json::fromJSON<Message::Interaction>(json)) {}\n            InteractionType type = InteractionType::NONE;\n            std::string name;\n            User user;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair                      (&Interaction::ID       , "id"        , json::REQUIRIED_FIELD),\n                    json::pair<json::EnumTypeHelper>(&Interaction::type     , "type"      , json::REQUIRIED_FIELD),\n                    json::pair                      (&Interaction::name     , "name"      , json::OPTIONAL_FIELD ),\n                    json::pair                      (&Interaction::user     , "user"      , json::OPTIONAL_FIELD )\n                );\n            JSONStructEnd\n        };\n        Interaction interaction;\n        Snowflake<DiscordObject> applicationID;\n        //components\n        std::vector<std::shared_ptr<BaseComponent>> components;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Message::ID               , "id"                , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::channelID        , "channel_id"        , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::serverID         , "guild_id"          , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::author           , "author"            , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::content          , "content"           , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::member           , "member"            , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::timestamp        , "timestamp"         , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::editedTimestamp  , "edited_timestamp"  , json::NULLABLE_FIELD ),\n                json::pair                           (&Message::tts              , "tts"               , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::mentionEveryone  , "mention_everyone"  , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::mentions         , "mentions"          , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::mentionRoles     , "mention_roles"     , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::attachments      , "attachments"       , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::embeds           , "embeds"            , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::reactions        , "reactions"         , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::pinned           , "pinned"            , json::REQUIRIED_FIELD),\n                json::pair                           (&Message::webhookID        , "webhook_id"        , json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper     >(&Message::type             , "type"              , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Message::stickers         , "stickers"          , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::messageReference , "message_reference" , json::OPTIONAL_FIELD ),\n                json::pair<json::SmartPtrTypeHelper >(&Message::referencedMessage, "referenced_message", json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper     >(&Message::flags            , "flags"             , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::interaction      , "interaction"       , json::OPTIONAL_FIELD ),\n                json::pair                           (&Message::applicationID    , "application_id"    , json::OPTIONAL_FIELD ),\n                json::pair<json::ContainerTypeHelper>(&Message::components       , "components"        , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    inline MessageReference::MessageReference(const Message& message) :\n        messageID(message.ID),\n        channelID(message.channelID),\n        serverID(message.serverID)\n    {}\n\n    struct MessageRevisions {\n        MessageRevisions(json::Value& json) :\n            messageID(json["id"]), channelID(json["channel_id"]), RevisionsJSON(json)\n        {}\n        inline void applyChanges(Message& outOfDateMessage) {\n            assert(outOfDateMessage.ID == messageID);\n            json::fromJSON(outOfDateMessage, RevisionsJSON);\n        }\n        Snowflake<Message> messageID;\n        Snowflake<Channel> channelID;\n        json::Value& RevisionsJSON;\n    };\n\n    enum class MentionReplierFlag {\n        NotSet = -2,\n        DoNotMentionReply = false,\n        MentionReply = true\n    };\n\n    //allow mentions parse has different behaviors when undefined and empty.\n    //allow mentions parse is also a array. the other values that have this\n    //kind of behavior, where a value makes discord do different thinsg based\n    //on it being defined or not, is that they are a primitive json type or\n    //an object. This one is an array, making it special.\n    template<class Container, template<class...> class TypeHelper>\n    struct AllowMentionsParseHelper :\n        public json::ToContainerFunction<Container, TypeHelper>,\n        public json::FromContainerFunction<Container, TypeHelper>,\n        public json::IsArrayFunction\n    {\n        static inline bool empty(const Container& value) {\n            return value.size() == 1 && value.front().empty();\n        }\n    };\n\n    struct AllowedMentions {\n    public:\n        using ParseValueType = std::string;\n        using ParseContainer = std::vector<std::string>;\n\n        AllowedMentions() = default;\n        ~AllowedMentions() = default;\n        AllowedMentions(int) : parse({}) {}\n        AllowedMentions(const json::Value & json);\n        AllowedMentions(const nonstd::string_view& json) :\n            AllowedMentions(json::fromJSON<AllowedMentions>(json)) {}\n        ParseContainer parse = {""};\n        std::vector<Snowflake<Role>> roles;\n        std::vector<Snowflake<User>> users;\n        enum class MentionReplierFlag {\n            NotSet = -2,\n            WillNotMentionReply = false,\n            MentionReply = true\n        };\n        MentionReplierFlag repliedUser = MentionReplierFlag::NotSet;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::parse      , "parse"       , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::roles      , "roles"       , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&AllowedMentions::users      , "users"       , json::OPTIONAL_FIELD),\n                json::pair<json::EnumTypeHelper     >(&AllowedMentions::repliedUser, "replied_user", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n        inline const bool empty() const {\n            return (parse.size() == 1 && parse[0].empty()) && repliedUser == MentionReplierFlag::NotSet;\n        }\n    };\n\n    template<>\n    struct GetDefault<AllowedMentions::MentionReplierFlag> {\n        static inline const AllowedMentions::MentionReplierFlag get() {\n            return AllowedMentions::MentionReplierFlag::NotSet;\n        } \n    };\n\n    template<>\n    struct GetEnumBaseType<AllowedMentions::MentionReplierFlag> {\n        //this makes the json wrapper know to use getBool instead of getInt\n        using Value = bool; \n    };\n\n    template<class Type>\n    struct MessageParams : public DiscordObject {\n        Snowflake<Channel> channelID;\n        std::string content = {};\n        std::vector<Embed> embed;\n        AllowedMentions allowedMentions;\n        std::vector<std::shared_ptr<BaseComponent>> components;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Type::content        , "content"         , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Type::embed          , "embed"           , json::OPTIONAL_FIELD),\n                json::pair                           (&Type::allowedMentions, "allowed_mentions", json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Type::components     , "components"      , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct SendMessageParams : MessageParams<SendMessageParams> {\n    public:\n        bool tts = false;\n        MessageReference messageReference;\n\n        JSONStructStart\n            std::tuple_cat(\n                MessageParams<SendMessageParams>::JSONStruct,\n                std::make_tuple(\n                    json::pair(&SendMessageParams::tts             , "tts"              , json::OPTIONAL_FIELD ),\n                    json::pair(&SendMessageParams::messageReference, "message_reference", json::OPTIONAL_FIELD )\n                )\n            );\n        JSONStructEnd\n    };\n\n    struct EditMessageParams : MessageParams<EditMessageParams> {\n    public:\n        Snowflake<Message> messageID;\n        Message::Flags flags = Message::Flags::DEFAULT;\n        std::vector<Attachment> attachments;\n\n        JSONStructStart\n            std::tuple_cat(\n                MessageParams<EditMessageParams>::JSONStruct,\n                std::make_tuple(\n                    json::pair<json::EnumTypeHelper     >(&EditMessageParams::flags      , "flags"      , json::OPTIONAL_FIELD),\n                    json::pair<json::ContainerTypeHelper>(&EditMessageParams::attachments, "attachments", json::OPTIONAL_FIELD)\n                )\n            );\n        JSONStructEnd\n    };\n\n    template<class Type>\n    struct BaseEditWebhookParams : public DiscordObject {\n    public:\n        tl::optional<std::string> content;\n        tl::optional<std::vector<Embed>> embeds;\n        AllowedMentions allowedMentions;\n        tl::optional<std::vector<std::shared_ptr<BaseComponent>>> components;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair<json::OptionalTypeHelper>                                        (&Type::content        , "content"         , json::OPTIONAL_FIELD),\n                json::ComplexPair<json::OptionalTypeHelper, json::ContainerTypeHelper>::pair(&Type::embeds         , "embeds"          , json::OPTIONAL_FIELD),\n                json::pair                                                                  (&Type::allowedMentions, "allowed_mentions", json::OPTIONAL_FIELD),\n                json::ComplexPair<json::OptionalTypeHelper, json::ContainerTypeHelper>::pair(&Type::components     , "components"      , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EditWebhookParams : public BaseEditWebhookParams<EditWebhookParams> {\n    public:\n        JSONStructStart\n            std::tuple_cat(\n                BaseEditWebhookParams<EditWebhookParams>::JSONStruct\n            );\n        JSONStructEnd\n    };\n\n    template<class Type>\n    struct BaseWebHookParams : public DiscordObject {\n    public:\n        bool tts = false;\n        std::string content;\n        std::vector<Embed> embeds;\n        AllowedMentions allowedMentions;\n        std::vector<std::shared_ptr<BaseComponent>> components;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Type::content         , "content"          , json::OPTIONAL_FIELD),\n                json::pair                           (&Type::tts             , "tts"              , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Type::embeds          , "embeds"           , json::OPTIONAL_FIELD),\n                json::pair                           (&Type::allowedMentions , "allowed_mentions" , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Type::components      , "components"       , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct WebHookParams : public BaseWebHookParams<WebHookParams> {\n    public:\n        \n        std::string username;\n        std::string avatarURL;\n        bool tts = false;\n        JSONStructStart\n            std::tuple_cat(\n                BaseWebHookParams<WebHookParams>::JSONStruct,\n                std::make_tuple(\n                    json::pair(&WebHookParams::username, "username", json::OPTIONAL_FIELD),\n                    json::pair(&WebHookParams::avatarURL, "avatar_url", json::OPTIONAL_FIELD)\n                )\n            );\n        JSONStructEnd\n    };\n}\n')),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Updated on 28 October 2023 at 21:20:08 UTC"))}m.isMDXComponent=!0}}]);