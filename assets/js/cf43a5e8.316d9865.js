"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[894],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const r={},s=o.createContext(r);function a(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:n},e.children)}},9329:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"slash-commands","title":"Slash Commands","description":"Using slash commands, you can have commands without the need of read messages intents. It also gives a user a standardized graphical user interface.","source":"@site/docs/slash-commands.md","sourceDirName":".","slug":"/slash-commands","permalink":"/sleepy-discord/docs/slash-commands","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1758418732000,"frontMatter":{"title":"Slash Commands"},"sidebar":"Docs","previous":{"title":"Connection Options","permalink":"/sleepy-discord/docs/connect-options"},"next":{"title":"Summary","permalink":"/sleepy-discord/docs/api"}}');var r=t(4848),s=t(8453);const a={title:"Slash Commands"},i=void 0,c={},d=[{value:"Add Commands",id:"add-commands",level:2},{value:"Responding to Commands",id:"responding-to-commands",level:2},{value:"Adding Options",id:"adding-options",level:2},{value:"Responding to Options",id:"responding-to-options",level:2},{value:"Adding Choices",id:"adding-choices",level:2},{value:"Autocomplete",id:"autocomplete",level:2},{value:"Context Menus",id:"context-menus",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Using slash commands, you can have commands without the need of read messages intents. It also gives a user a standardized graphical user interface."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Slash Commands are only available in the develop branch.\r\nMany features have not been implemented yet.\r\nSlash Commands are still being worked on. The main parts of slash commands are finished but many new features like localization, attachment option types, and permissions are still being worked on."})}),"\n",(0,r.jsx)(n.h2,{id:"add-commands",children:"Add Commands"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'const std::string name = "hello";\r\nconst std::string description = "says hello";\r\n\r\ncreateGlobalAppCommand(getID(), name, description);\n'})}),"\n",(0,r.jsx)(n.p,{children:"or"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'const std::string name = "hello";\r\nconst std::string description = "says hello";\r\n\r\ncreateServerAppCommand(getID(), server.ID, name, description);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["There's two create app command request, you can choose from ",(0,r.jsx)(n.code,{children:"createGlobalAppCommand"}),", and ",(0,r.jsx)(n.code,{children:"createServerAppCommand"})," for commands that are available depending on the server. The library also provides a ",(0,r.jsx)(n.code,{children:"createAppCommand"})," that combines the two."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Names for commands, values, and choices have a character limit and don't allow some characters. ",(0,r.jsx)(n.a,{href:"https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-naming",children:"More info here."})]})}),"\n",(0,r.jsx)(n.h2,{id:"responding-to-commands",children:"Responding to Commands"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'void onInteraction(SleepyDiscord::Interaction interaction) override {\r\n    if (interaction.data.name == "hello") {\r\n        SleepyDiscord::Interaction::Response<> response;\r\n        response.type = SleepyDiscord::InteractionCallbackType::ChannelMessageWithSource;\r\n        response.data.content = "hello";\r\n        client.createInteractionResponse(interaction.ID, interaction.token, response);\r\n    } else {\r\n        //not found\r\n        SleepyDiscord::Interaction::Response<> response;\r\n        response.type = SleepyDiscord::InteractionCallbackType::ChannelMessageWithSource;\r\n        response.data.content = "Couldn\'t find command";\r\n        response.data.flags = SleepyDiscord::InteractionAppCommandCallbackData::Flags::Ephemeral; //only for the user to see\r\n        createInteractionResponse(interaction, interaction.token, response);\r\n        return;\r\n    }\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When a user uses a command, the bot will hear about it in the ",(0,r.jsx)(n.code,{children:"onInteraction"})," event. The interaction's data object will have the name of the command that was used.\r\nThe bot should create a Interaction Response, with a type and content. After that, the bot sends a Create Interaction Response request, using the interaction's ID, and token."]}),"\n",(0,r.jsx)(n.h2,{id:"adding-options",children:"Adding Options"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'const std::string name = "add";\r\nconst std::string description = "sum of two number";\r\nstd::vector<SleepyDiscord::AppCommand::Option> options;\r\n\r\nSleepyDiscord::AppCommand::Option left;\r\nleft.name = "left";\r\nleft.isRequired = true;\r\nleft.description = "The number to the left of the + sign";\r\nleft.type = SleepyDiscord::AppCommand::Option::TypeHelper<double>::getType();\r\noptions.push_back(std::move(left));\r\n\r\nSleepyDiscord::AppCommand::Option right;\r\nright.name = "right";\r\nright.isRequired = true;\r\nright.description = "The number to the right of the + sign";\r\nright.type = SleepyDiscord::AppCommand::Option::TypeHelper<double>::getType();\r\noptions.push_back(std::move(right));\r\n\r\ncreateGlobalAppCommand(getID(), name, description, std::move(options));\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When creating the list of the options, you'll need to create a ",(0,r.jsx)(n.code,{children:"SleepyDiscord::AppCommand::Option"})," for each option and move that into the options.\r\nThe required data is type, name, and description. The type needs to be a value in the ",(0,r.jsx)(n.code,{children:"SleepyDiscord::AppCommand::Option::Type"})," enum. You can use ",(0,r.jsx)(n.code,{children:"SleepyDiscord::AppCommand::Option::TypeHelper"})," to get the type for things like string, int, and bool.\r\nThere are some more advanced useful types like ",(0,r.jsx)(n.code,{children:"SleepyDiscord::AppCommand::Option::Type::MENTIONABLE"}),", ",(0,r.jsx)(n.code,{children:"SleepyDiscord::AppCommand::Option::SUB_COMMAND"}),", and ",(0,r.jsx)(n.code,{children:"SleepyDiscord::AppCommand::Option::SUB_COMMAND_GROUP"}),".\r\nAnother important thing about Options is that they can't easily be copied because the Choices in Options can't be copied, but they can easily be moved with ",(0,r.jsx)(n.code,{children:"std::move"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"responding-to-options",children:"Responding to Options"}),"\n",(0,r.jsx)(n.p,{children:"There's more than one way to handle this, that comes with different pros and cons."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'void onInteraction(SleepyDiscord::Interaction interaction) override {\r\n    if (interaction.data.name != "add")\r\n        return; //not found\r\n\r\n    for (auto& option : interaction.data.options) {\r\n        if (option.name == "left" || option.name == "right") {\r\n            double num;\r\n            if (option.get(num)) {\r\n                answer += num;\r\n            } else {\r\n                return; //fail\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'void onInteraction(SleepyDiscord::Interaction interaction) override {\r\n    if (interaction.data.name != "add")\r\n        return; //not found\r\n\r\n    for (auto& option : interaction.data.options) {\r\n        if (option.name == "left" || option.name == "right") {\r\n            try {\r\n                answer += option.get<double>();\r\n            } catch (...) {\r\n                //fail\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Mainly different ways to error check that parsing the JSON data didn't run into issues. Since we don't know exactly what the type is, it's recommended to use matching types, but there is still a possibility for errors during parsing."}),"\n",(0,r.jsx)(n.h2,{id:"adding-choices",children:"Adding Choices"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'SleepyDiscord::AppCommand::Option iceCream;\r\niceCream.name = "ice-cream";\r\niceCream.description = "Which ice-cream would you like";\r\niceCream.type = SleepyDiscord::AppCommand::Option::TypeHelper<std::string>::getType();\r\n\r\nSleepyDiscord::AppCommand::Option::Choice vanilla;\r\nvanilla.name = "Vanilla";\r\nvanilla.set<std::string>("vanilla");\r\niceCream.choices.push_back(std::move(vanilla));\r\n\r\nSleepyDiscord::AppCommand::Option::Choice matcha;\r\nvanilla.name = "Matcha";\r\nvanilla.set<std::string>("matcha");\r\niceCream.choices.push_back(std::move(matcha));\r\n\r\nSleepyDiscord::AppCommand::Option::Choice mixed;\r\nvanilla.name = "Mixed";\r\nvanilla.set<std::string>("mixed");\r\niceCream.choices.push_back(std::move(mixed));\n'})}),"\n",(0,r.jsx)(n.p,{children:"Adding choices requires setting with a type and a value. It's recommended that you use matching types."}),"\n",(0,r.jsx)(n.p,{children:"To respond to choices, it's the same as responding to the option like earlier but look out for the values that were set in your choices."}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"The choices limit is 25, try autocomplete if you are going over that limit"})}),"\n",(0,r.jsx)(n.h2,{id:"autocomplete",children:"Autocomplete"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Adding the option"',children:'SleepyDiscord::AppCommand::Option search;\r\nsearch.name = "search";\r\nsearch.description = "looks though the large database";\r\nsearch.type = SleepyDiscord::AppCommand::Option::TypeHelper<std::string>::getType();\r\nsearch.autocomplete = true;\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"Choices need to be empty for autocomplete to be allowed"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Responding to the user typing"',children:'void onInteraction(SleepyDiscord::Interaction interaction) override {\r\n    if (interaction.type == SleepyDiscord::Interaction::Type::ApplicationCommandAutocomplete) {\r\n        try {\r\n            std::string query = option.get<std::string>();\r\n            SleepyDiscord::Interaction::AutocompleteResponse response;\r\n            SleepyDiscord::AppCommand::Option::Choice extraE;\r\n            extraE.name = "E";\r\n            extraE.set<std::string>(query + "e");\r\n            response.data.choices.push_back(std::move(extraE));\r\n            client.createInteractionResponse(interaction.ID, interaction.token, response);\r\n        } catch (...) {\r\n            //fail\r\n        }\r\n    } else {\r\n        // execute search command\r\n    }\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Using autocomplete, your bot can set the choices dynamically as the user types their command. You need to set an option without any choices to allow autocomplete by setting  ",(0,r.jsx)(n.code,{children:"option.autocomplete"})," to true. After that, the bot needs to respond to the options as the user types with a list of choices using an ",(0,r.jsx)(n.code,{children:"Interaction::AutocompleteResponse"}),". You can also tell when the user is typing with autocomplete using ",(0,r.jsx)(n.code,{children:"interaction.type"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"context-menus",children:"Context Menus"}),"\n",(0,r.jsx)(n.p,{children:"There's 2 forms of commands that use context menus, user commands and message commands."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'const std::string name = "star";\r\nconst std::string description = "add a star a message";\r\nconst bool defaultPermissions = true;\r\n//The type needs to be set to message\r\nconst SleepyDiscord::AppCommand::Type type = SleepyDiscord::AppCommand::Type::MESSAGE;\r\n\r\nclient.createGlobalAppCommand(getID(), name, description,\r\n    SleepyDiscord::AppCommand::emptyOptions, defaultPermissions, type);\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Responding to Message Commands"',children:'void onInteraction(SleepyDiscord::Interaction interaction) override {\r\n    if (interaction.data.name != "star")\r\n        return; //not found\r\n\r\n    SleepyDiscord::Message message;\r\n    if (!interaction.data.resolved.messages.find(interaction.data.targetID, message)) {\r\n        return; //fail\r\n    }\r\n    // use message to get required data\r\n    message.content;\r\n}\r\n\r\n//or\r\nvoid onInteraction(SleepyDiscord::Interaction interaction) override {\r\n    if (interaction.data.name != "star")\r\n        return; //not found\r\n        \r\n    auto iterator = interaction.data.resolved.messages.find(interaction.data.targetID);\r\n    if (iterator == interaction.data.resolved.messages.end()) {\r\n        return; //fail\r\n    }\r\n    SleepyDiscord::Message message = iterator->value;\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["These types of commands do not contain any options and instead get parameters via ",(0,r.jsx)(n.code,{children:"interaction.data.resolved"}),". Which contains the objects that are selected or in other objects related to the target, ",(0,r.jsx)(n.code,{children:"interaction.data.targetID"}),". For example, if someone is mentioned in a message, you can find that user's User object in ",(0,r.jsx)(n.code,{children:"interaction.data.resolved.users"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);