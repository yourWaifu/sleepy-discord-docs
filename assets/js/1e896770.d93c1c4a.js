"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[336],{3758:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"snowflake","title":"Snowflakes and IDs","description":"Snowflakes very common type is used for identification. Defined as SleepyDiscord::Snowflake.","source":"@site/docs/snowflake.md","sourceDirName":".","slug":"/snowflake","permalink":"/sleepy-discord/docs/snowflake","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1758418732000,"frontMatter":{"title":"Snowflakes and IDs"},"sidebar":"Docs","previous":{"title":"Unicode and Emojis","permalink":"/sleepy-discord/docs/unicode"},"next":{"title":"Connection Options","permalink":"/sleepy-discord/docs/connect-options"}}');var i=s(4848),a=s(8453);const o={title:"Snowflakes and IDs"},r=void 0,l={},c=[{value:"Unique",id:"unique",level:2},{value:"Valid",id:"valid",level:2},{value:"Casting",id:"casting",level:2},{value:"To Snowflake",id:"to-snowflake",level:3},{value:"To String or Int",id:"to-string-or-int",level:3},{value:"Number",id:"number",level:3},{value:"Timestamp",id:"timestamp",level:2},{value:"Equality ==",id:"equality-",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Snowflakes very common type is used for identification. Defined as ",(0,i.jsx)(n.a,{href:"api#struct_sleepy_discord_1_1_snowflake",children:"SleepyDiscord::Snowflake"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"unique",children:"Unique"}),"\n",(0,i.jsxs)(n.p,{children:["2 IDs for 2 different objects of the ",(0,i.jsx)(n.strong,{children:"same type"})," should not have the same ID. However, 2 ID for objects of ",(0,i.jsx)(n.strong,{children:"different types"})," can have the same ID. As such the library uses a template class to help differentiate the two. Often a Server and it's general channel and it's default role has the same ID, so it's useful for getting objects that would be created when another object is created on the same operation."]}),"\n",(0,i.jsx)(n.h2,{id:"valid",children:"Valid"}),"\n",(0,i.jsx)(n.p,{children:"For empty IDs, the library uses an empty string to represent when an ID isn't available. For example, a Direct Message Channel would have an no Server ID and as such it's ID is an empty string."}),"\n",(0,i.jsx)(n.p,{children:"However, if it's not empty, the only way to know if it's valid is by giving the ID to Discord."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"if (messageID.empty())\n"})}),"\n",(0,i.jsx)(n.h2,{id:"casting",children:"Casting"}),"\n",(0,i.jsx)(n.h3,{id:"to-snowflake",children:"To Snowflake"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'Snowflake<Message> ID = "string";\r\nSnowflake<Message> ID = message; //Same as message.ID\r\nSnowflake<Message> ID = 90485;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"to-string-or-int",children:"To String or Int"}),"\n",(0,i.jsx)(n.p,{children:"The Snowflake stores it's data in a string that you can cast to. You can also get a number if you like instead."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"std::string ID = messageID; //implicit\r\nstd::string ID = messagesID.string();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"number",children:"Number"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int64_t ID = messageID.number(); // throws if empty\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"When using .number() or .timestamp(), make sure that snowflake isn't empty first or the library will throw an exception."})}),"\n",(0,i.jsx)(n.h2,{id:"timestamp",children:"Timestamp"}),"\n",(0,i.jsx)(n.p,{children:"Snowflakes contains some data that tells you when an object was create, and the worker and process that created it. The time is what's useful tho, so the library can extract this data for you."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"```cpp\r\nstd::chrono::time_point<std::chrono::steady_clock> birth = messageID.timestamp(); // throws if ID is empty\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"When using .number() or .timestamp(), make sure that snowflake isn't empty first or you'll get an error."})}),"\n",(0,i.jsx)(n.h2,{id:"equality-",children:"Equality =="}),"\n",(0,i.jsx)(n.p,{children:"This lets you check if you have the right object."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"if (message.channelID == channel.ID)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(6540);const i={},a=t.createContext(i);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);