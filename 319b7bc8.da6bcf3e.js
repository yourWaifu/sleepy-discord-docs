(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{118:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var r=n(3),a=n(7),s=(n(0),n(317)),i={title:"include/sleepy_discord/gateway.h"},c={unversionedId:"reference/Files/gateway_8h",id:"reference/Files/gateway_8h",isDocsHomePage:!1,title:"include/sleepy_discord/gateway.h",description:"Namespaces",source:"@site/docs\\reference\\Files\\gateway_8h.md",slug:"/reference/Files/gateway_8h",permalink:"/sleepy-discord-docs/docs/reference/Files/gateway_8h",version:"current",sidebar:"Reference",previous:{title:"sleepy_discord/gateway.cpp",permalink:"/sleepy-discord-docs/docs/reference/Files/gateway_8cpp"},next:{title:"sleepy_discord/http.cpp",permalink:"/sleepy-discord-docs/docs/reference/Files/http_8cpp"}},l=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Types",id:"types",children:[]},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum Status",id:"enum-status",children:[]},{value:"enum GameType",id:"enum-gametype",children:[]}]},{value:"Source code",id:"source-code",children:[]}],o={toc:l};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(s.b)("wrapper",Object(r.a)({},o,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h2",{id:"namespaces"},"Namespaces"),Object(s.b)("table",null,Object(s.b)("thead",{parentName:"table"},Object(s.b)("tr",{parentName:"thead"},Object(s.b)("th",{parentName:"tr",align:null},"Name"))),Object(s.b)("tbody",{parentName:"table"},Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),Object(s.b)("h2",{id:"classes"},"Classes"),Object(s.b)("table",null,Object(s.b)("thead",{parentName:"table"},Object(s.b)("tr",{parentName:"thead"},Object(s.b)("th",{parentName:"tr",align:null}),Object(s.b)("th",{parentName:"tr",align:null},"Name"))),Object(s.b)("tbody",{parentName:"table"},Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_game"},"SleepyDiscord::Game")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_ready"},"SleepyDiscord::Ready")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_activity_timestamp_type_helper"},"SleepyDiscord::ActivityTimestampTypeHelper")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_activity_timestamp"},"SleepyDiscord::ActivityTimestamp")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_activity_party"},"SleepyDiscord::ActivityParty")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_activity_assets"},"SleepyDiscord::ActivityAssets")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_activity_secrets"},"SleepyDiscord::ActivitySecrets")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_application"},"SleepyDiscord::Application")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_activity"},"SleepyDiscord::Activity")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_get_default_3_01_activity_1_1_activity_type_01_4"},"SleepyDiscord::GetDefault< Activity::ActivityType >")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_presence_update"},"SleepyDiscord::PresenceUpdate")))),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"struct"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_server_members_chunk"},"SleepyDiscord::ServerMembersChunk")))))),Object(s.b)("h2",{id:"types"},"Types"),Object(s.b)("table",null,Object(s.b)("thead",{parentName:"table"},Object(s.b)("tr",{parentName:"thead"},Object(s.b)("th",{parentName:"tr",align:null}),Object(s.b)("th",{parentName:"tr",align:null},"Name"))),Object(s.b)("tbody",{parentName:"table"},Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"enum"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Files/gateway_8h#enum-status"},"Status"))," { statusError = 0, online, doNotDisturb, idle, invisible, offline}")),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"enum"),Object(s.b)("td",{parentName:"tr",align:null},Object(s.b)("strong",{parentName:"td"},Object(s.b)("a",{parentName:"strong",href:"/docs/reference/Files/gateway_8h#enum-gametype"},"GameType"))," { Playing = 0, Streaming = 1}")))),Object(s.b)("h2",{id:"types-documentation"},"Types Documentation"),Object(s.b)("h3",{id:"enum-status"},"enum Status"),Object(s.b)("table",null,Object(s.b)("thead",{parentName:"table"},Object(s.b)("tr",{parentName:"thead"},Object(s.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(s.b)("th",{parentName:"tr",align:null},"Value"),Object(s.b)("th",{parentName:"tr",align:null},"Description"))),Object(s.b)("tbody",{parentName:"table"},Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"statusError"),Object(s.b)("td",{parentName:"tr",align:null},"0"),Object(s.b)("td",{parentName:"tr",align:null})),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"online"),Object(s.b)("td",{parentName:"tr",align:null}),Object(s.b)("td",{parentName:"tr",align:null})),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"doNotDisturb"),Object(s.b)("td",{parentName:"tr",align:null}),Object(s.b)("td",{parentName:"tr",align:null})),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"idle"),Object(s.b)("td",{parentName:"tr",align:null}),Object(s.b)("td",{parentName:"tr",align:null})),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"invisible"),Object(s.b)("td",{parentName:"tr",align:null}),Object(s.b)("td",{parentName:"tr",align:null})),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"offline"),Object(s.b)("td",{parentName:"tr",align:null}),Object(s.b)("td",{parentName:"tr",align:null})))),Object(s.b)("h3",{id:"enum-gametype"},"enum GameType"),Object(s.b)("table",null,Object(s.b)("thead",{parentName:"table"},Object(s.b)("tr",{parentName:"thead"},Object(s.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(s.b)("th",{parentName:"tr",align:null},"Value"),Object(s.b)("th",{parentName:"tr",align:null},"Description"))),Object(s.b)("tbody",{parentName:"table"},Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"Playing"),Object(s.b)("td",{parentName:"tr",align:null},"0"),Object(s.b)("td",{parentName:"tr",align:null})),Object(s.b)("tr",{parentName:"tbody"},Object(s.b)("td",{parentName:"tr",align:null},"Streaming"),Object(s.b)("td",{parentName:"tr",align:null},"1"),Object(s.b)("td",{parentName:"tr",align:null})))),Object(s.b)("h2",{id:"source-code"},"Source code"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <ctime>\n#include <array>\n#include "discord_object_interface.h"\n#include "user.h"\n#include "channel.h"\n#include "server.h"\n\nnamespace SleepyDiscord {\n    enum Status {\n        statusError = 0,\n        online         ,\n        doNotDisturb   ,\n        idle           ,\n        invisible      ,\n        offline        \n    };\n\n    enum GameType {\n        Playing = 0,  //calling this Game causes issues\n        Streaming = 1\n    };\n\n    struct Game : public DiscordObject {\n        std::string name = "";\n        GameType type;\n        std::string url = ""; //used when type is Streaming\n    };\n\n    struct Ready : public DiscordObject {\n    public:\n        Ready() = default;\n        //Ready(const std::string * rawJSON);\n        Ready(const json::Value & rawJSON);\n        Ready(const nonstd::string_view & rawJSON);\n        //Ready(const json::Values values);\n        int v;  //gateway protocol version\n        User user;\n        std::list<Channel> privateChannels;\n        std::list<UnavailableServer> servers;\n        std::string sessionID;\n        //std::vector<std::string> trace;\n        std::array<int, 2> shard = { {0, 1} };\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Ready::v              , "v"               , json::REQUIRIED_FIELD),\n                json::pair                           (&Ready::user           , "user"            , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Ready::privateChannels, "private_channels", json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Ready::servers        , "guilds"          , json::REQUIRIED_FIELD),\n                json::pair                           (&Ready::sessionID      , "session_id"      , json::REQUIRIED_FIELD),\n                //This doesn\'t work anymore\n                //json::pair(&Ready::trace          , json::toArray<std::string>      , "_trace"          , json::REQUIRIED_FIELD),\n                json::pair<json::StdArrayTypeHelper >(&Ready::shard          , "shard"           , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    template<class Type>\n    struct ActivityTimestampTypeHelper {\n        using TypeHelper = json::PrimitiveTypeHelper<Type>;\n        static inline Type toType(const json::Value& value) {\n            //For some reason Discord sends a string sometimes\n            //instead of an int\n            return value.IsString() ?\n                static_cast<Type>(\n                    std::stoll(\n                        std::string(value.GetString(),\n                        value.GetStringLength())\n                    )\n                )\n                :\n                TypeHelper::toType(value);\n        }\n        static inline bool empty(const Type& value) {\n            return TypeHelper::empty(value);\n        }\n        static inline json::Value fromType(const Type& value, json::Value::AllocatorType& allocator) {\n            return TypeHelper::fromType(value, allocator);\n        }\n    };\n\n    struct ActivityTimestamp : public DiscordObject {\n    public:\n        ActivityTimestamp() = default;\n        ~ActivityTimestamp() = default;\n        ActivityTimestamp(const json::Value & json);\n        ActivityTimestamp(const nonstd::string_view & json);\n        Time start;\n        Time end;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair<ActivityTimestampTypeHelper>(&ActivityTimestamp::start, "start", json::OPTIONAL_FIELD),\n                json::pair<ActivityTimestampTypeHelper>(&ActivityTimestamp::end  , "end"  , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ActivityParty : public DiscordObject {\n    public:\n        ActivityParty() = default;\n        ~ActivityParty() = default;\n        ActivityParty(const json::Value & json);\n        ActivityParty(const nonstd::string_view & json);\n        std::string ID;\n        std::array<int64_t, 2> size;\n        int64_t& currentSize = size[0];\n        int64_t& maxSize = size[1];\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                          (&ActivityParty::ID  , "id"  , json::OPTIONAL_FIELD),\n                json::pair<json::StdArrayTypeHelper>(&ActivityParty::size, "size", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ActivityAssets : public DiscordObject {\n    public:\n        ActivityAssets() = default;\n        ~ActivityAssets() = default;\n        ActivityAssets(const json::Value & json);\n        ActivityAssets(const nonstd::string_view & json);\n        std::string largeImage;\n        std::string largeText;\n        std::string smallImage;\n        std::string smallText;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&ActivityAssets::largeImage, "large_image", json::OPTIONAL_FIELD),\n                json::pair(&ActivityAssets::largeText , "large_text" , json::OPTIONAL_FIELD),\n                json::pair(&ActivityAssets::smallImage, "small_image", json::OPTIONAL_FIELD),\n                json::pair(&ActivityAssets::smallText , "small_text" , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ActivitySecrets : public DiscordObject {\n    public:\n        ActivitySecrets() = default;\n        ~ActivitySecrets() = default;\n        ActivitySecrets(const json::Value & json);\n        ActivitySecrets(const nonstd::string_view & json);\n        std::string join;\n        std::string spectate;\n        std::string match;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&ActivitySecrets::join    , "join"    , json::OPTIONAL_FIELD),\n                json::pair(&ActivitySecrets::spectate, "spectate", json::OPTIONAL_FIELD),\n                json::pair(&ActivitySecrets::match   , "match"   , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    //This is here for the snowflake\n    struct Application {};\n\n    struct Activity : public DiscordObject {\n    public:\n        Activity() = default;\n        ~Activity() = default;\n        Activity(const json::Value & json);\n        Activity(const nonstd::string_view & json);\n        std::string name;\n        enum ActivityType {\n            ACTIVITY_TYPE_NONE = -1,\n            GAME               = 0,\n            STREAMING          = 1,\n            LISTENING          = 2,\n        } type = ACTIVITY_TYPE_NONE;\n        std::string url;\n        ActivityTimestamp timestamps;\n        Snowflake<Application> applicationID;\n        std::string details;\n        std::string state;\n        //ActivityParty party;\n        ActivityAssets assets;\n        ActivitySecrets secrets;\n        bool instance;\n        enum ActivityFlags {\n            NONE         = 0 << 0,\n            INSTANCE     = 1 << 0,\n            JOIN         = 1 << 1,\n            SPECTATE     = 1 << 2,\n            JOIN_REQUEST = 1 << 3,\n            SYNC         = 1 << 4,\n            PLAY         = 1 << 5\n        } flags = NONE;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                      (&Activity::name         , "name"          , json::REQUIRIED_FIELD        ),\n                json::pair<json::EnumTypeHelper>(&Activity::type         , "type"          , json::REQUIRIED_FIELD        ),\n                json::pair                      (&Activity::url          , "url"           , json::OPTIONAL_NULLABLE_FIELD),\n                json::pair                      (&Activity::timestamps   , "timestamps"    , json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::applicationID, "application_id", json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::details      , "details"       , json::OPTIONAL_NULLABLE_FIELD),\n                json::pair                      (&Activity::state        , "state"         , json::OPTIONAL_NULLABLE_FIELD),\n                //json::pair                      (&Activity::party        , "party"         , json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::assets       , "assets"        , json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::secrets      , "secrets"       , json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::instance     , "instance"      , json::OPTIONAL_FIELD         ),\n                json::pair<json::EnumTypeHelper>(&Activity::flags        , "flags"         , json::OPTIONAL_FIELD         )\n            );\n        JSONStructEnd\n    };\n\n    template<>\n    struct GetDefault<Activity::ActivityType> {\n        static inline const Activity::ActivityType get() {\n            return Activity::ActivityType::ACTIVITY_TYPE_NONE;\n        }\n    };\n\n    struct PresenceUpdate : public DiscordObject {\n    public:\n        PresenceUpdate() = default;\n        ~PresenceUpdate() = default;\n        PresenceUpdate(const json::Value & json);\n        PresenceUpdate(const nonstd::string_view & json);\n        User user;\n        std::vector<Snowflake<Role>> roleIDs;\n        Activity currentActivity;\n        Snowflake<Server> serverID;\n        std::string status;\n        std::vector<Activity> activities;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&PresenceUpdate::user           , "user"      , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&PresenceUpdate::roleIDs        , "roles"     , json::REQUIRIED_FIELD),\n                json::pair                           (&PresenceUpdate::currentActivity, "game"      , json::NULLABLE_FIELD ),\n                json::pair                           (&PresenceUpdate::serverID       , "guild_id"  , json::OPTIONAL_FIELD ),\n                json::pair                           (&PresenceUpdate::status         , "status"    , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&PresenceUpdate::activities     , "activities", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ServerMembersChunk {\n        ServerMembersChunk() = default;\n        ServerMembersChunk(const json::Value& json);\n        ServerMembersChunk(const nonstd::string_view & json);\n        Snowflake<Server> serverID;\n        std::vector<ServerMember> members;\n        int chunkIndex;\n        int chunkCount;\n        std::vector<PresenceUpdate> presences;\n        std::string nonce;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&ServerMembersChunk::serverID  , "guild_id"   , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&ServerMembersChunk::members   , "members"    , json::REQUIRIED_FIELD),\n                json::pair                           (&ServerMembersChunk::chunkIndex, "chunk_index", json::REQUIRIED_FIELD),\n                json::pair                           (&ServerMembersChunk::chunkCount, "chunk_count", json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&ServerMembersChunk::presences , "presences"  , json::OPTIONAL_FIELD ),\n                json::pair                           (&ServerMembersChunk::nonce     , "nonce"      , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n}\n')),Object(s.b)("hr",null),Object(s.b)("p",null,"Updated on  9 February 2021 at 07:04:58 Eastern Standard Time"))}p.isMDXComponent=!0},317:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var r=n(0),a=n.n(r);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=a.a.createContext({}),p=function(e){var t=a.a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},b=function(e){var t=p(e.components);return a.a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,o=l(e,["components","mdxType","originalType","parentName"]),b=p(n),u=r,m=b["".concat(i,".").concat(u)]||b[u]||d[u]||s;return n?a.a.createElement(m,c(c({ref:t},o),{},{components:n})):a.a.createElement(m,c({ref:t},o))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var o=2;o<s;o++)i[o]=n[o];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);