(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{243:function(e,n,s){"use strict";s.r(n),s.d(n,"frontMatter",(function(){return i})),s.d(n,"metadata",(function(){return a})),s.d(n,"toc",(function(){return l})),s.d(n,"default",(function(){return d}));var t=s(3),r=s(7),o=(s(0),s(317)),i={title:"sleepy_discord/endpoints.cpp"},a={unversionedId:"reference/Files/endpoints_8cpp",id:"reference/Files/endpoints_8cpp",isDocsHomePage:!1,title:"sleepy_discord/endpoints.cpp",description:"Namespaces",source:"@site/docs\\reference\\Files\\endpoints_8cpp.md",slug:"/reference/Files/endpoints_8cpp",permalink:"/sleepy-discord-docs/docs/reference/Files/endpoints_8cpp",version:"current",sidebar:"Reference",previous:{title:"include/sleepy_discord/embed.h",permalink:"/sleepy-discord-docs/docs/reference/Files/embed_8h"},next:{title:"include/sleepy_discord/error.h",permalink:"/sleepy-discord-docs/docs/reference/Files/error_8h"}},l=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Functions",id:"functions",children:[]},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function createMessageBody",id:"function-createmessagebody",children:[]},{value:"function convertEmojiToURL",id:"function-convertemojitourl",children:[]},{value:"function optionalWebhookToken",id:"function-optionalwebhooktoken",children:[]}]},{value:"Source code",id:"source-code",children:[]}],c={toc:l};function d(e){var n=e.components,s=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(t.a)({},c,s,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"namespaces"},"Namespaces"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",{parentName:"tr",align:null},"Name"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),Object(o.b)("h2",{id:"functions"},"Functions"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",{parentName:"tr",align:null}),Object(o.b)("th",{parentName:"tr",align:null},"Name"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"std::string"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Files/endpoints_8cpp#function-createmessagebody"},"createMessageBody")),"(std::string & message, Embed & embed, TTS tts)")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"std::string"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Files/endpoints_8cpp#function-convertemojitourl"},"convertEmojiToURL")),"(const std::string emoji)")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"const char *"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Files/endpoints_8cpp#function-optionalwebhooktoken"},"optionalWebhookToken")),"(std::string webhookToken)")))),Object(o.b)("h2",{id:"functions-documentation"},"Functions Documentation"),Object(o.b)("h3",{id:"function-createmessagebody"},"function createMessageBody"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"std::string createMessageBody(\n    std::string & message,\n    Embed & embed,\n    TTS tts\n)\n")),Object(o.b)("h3",{id:"function-convertemojitourl"},"function convertEmojiToURL"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"std::string convertEmojiToURL(\n    const std::string emoji\n)\n")),Object(o.b)("h3",{id:"function-optionalwebhooktoken"},"function optionalWebhookToken"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"inline const char * optionalWebhookToken(\n    std::string webhookToken\n)\n")),Object(o.b)("h2",{id:"source-code"},"Source code"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},'#include <functional>\n#include "client.h"\n#include "discord_object_interface.h"\n#include "vector"\n\n#if _MSC_VER && !__INTEL_COMPILER\n#pragma warning( disable: 4458 ) //warns about variables that hide class members\n#endif\n\n//important note, all requests on sync mode throw on an http error\n\nnamespace SleepyDiscord {\n    void BaseDiscordClient::testFunction(std::string teststring) {\n\n    }\n    //\n    //channel functions\n    //\n\n    //ObjectResponse<Message> BaseDiscordClient::sendMessage(Snowflake<Channel> channelID, CreateMessageParams& params) {\n    //  return ObjectResponse<Message>{ request(Post, path("channels/{channel.id}/messages", { channelID }), json::stringifyObj(params)) };\n    //}\n\n    std::string createMessageBody(std::string& message, Embed& embed, TTS tts) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        rapidjson::Value content;\n        auto& allocator = doc.GetAllocator();\n        content.SetString(message.c_str(), message.length());\n        doc.AddMember("content", content, allocator);\n        if (tts == TTS::EnableTTS) doc.AddMember("tts", true, allocator);\n        if (!embed.empty()) doc.AddMember("embed", json::toJSON(embed, allocator), allocator);\n        return json::stringify(doc);\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::sendMessage(Snowflake<Channel> channelID, std::string message, Embed embed, TTS tts, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{ request(Post, path("channels/{channel.id}/messages", { channelID }), settings, createMessageBody(message, embed, tts)) };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::sendMessage(SendMessageParams params, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{ request(Post, path("channels/{channel.id}/messages", { params.channelID }), settings, json::stringifyObj(params)) };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::uploadFile(Snowflake<Channel> channelID, std::string fileLocation, std::string message, Embed embed, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{\n            request(Post, path("channels/{channel.id}/messages", { channelID }), settings, "", {\n                { "file", filePathPart{fileLocation} },\n                { "payload_json", createMessageBody(message, embed, TTS::DisableTTS) }\n            })\n        };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::editMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string newMessage, Embed embed, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{ request(Patch, path("channels/{channel.id}/messages/{message.id}", { channelID, messageID }), settings, createMessageBody(newMessage, embed, TTS::DisableTTS)) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("channels/{channel.id}/messages/{message.id}", { channelID, messageID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::bulkDeleteMessages(Snowflake<Channel> channelID, std::vector<Snowflake<Message>> messageIDs, RequestSettings<BoolResponse> settings) {\n        std::string JSON = "{\\"messages\\":[";\n        for (Snowflake<Message> messageID : messageIDs) {\n            JSON += messageID;\n            JSON += \',\';\n        }\n        if (messageIDs.size())\n            JSON.pop_back();\n        JSON += "]}";\n        return { request(Post, path("channels/{channel.id}/messages/bulk-delete", { channelID }), settings, JSON), EmptyRespFn() };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::editChannel(Snowflake<Channel> channelID, std::string name, std::string topic, RequestSettings<ObjectResponse<Channel>> settings) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        auto& allocator = doc.GetAllocator();\n        rapidjson::Value nameValue;\n        if (name != "") {\n            nameValue.SetString(name.c_str(), name.length());\n            doc.AddMember("name", nameValue, allocator);\n        }\n        rapidjson::Value topicValue;\n        if (topic != "") {\n            topicValue.SetString(topic.c_str(), topic.length());\n            doc.AddMember("topic", topicValue, allocator);\n        }\n        return ObjectResponse<Channel>{ request(Patch, path("channels/{channel.id}", { channelID }), settings, json::stringify(doc)) };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::editChannelName(Snowflake<Channel> channelID, std::string name, RequestSettings<ObjectResponse<Channel>> settings) {\n        return editChannel(channelID, name, "", settings);\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::editChannelTopic(Snowflake<Channel> channelID, std::string topic, RequestSettings<ObjectResponse<Channel>> settings) {\n        return editChannel(channelID, "", topic, settings);\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::deleteChannel(Snowflake<Channel> channelID, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{ request(Delete, path("channels/{channel.id}", { channelID }), settings) };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::getChannel(Snowflake<Channel> channelID, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{ request(Get, path("channels/{channel.id}", { channelID }), settings) };\n    }\n\n    ArrayResponse<Message> BaseDiscordClient::getMessages(Snowflake<Channel> channelID, GetMessagesKey when, Snowflake<Message> messageID, uint8_t _limit) {\n        const uint8_t trueLimit = 100 < _limit ? 100 : _limit;\n        std::string key;\n        switch (when) {\n        case around: key = "?around=" + messageID; break;\n        case before: key = "?before=" + messageID; break;\n        case after:  key = "?after="  + messageID; break;\n        case limit:  key = "?"                    ; break;\n        default:     key = ""                     ; break;\n        }\n        if (trueLimit != 0 && when != limit) key += \'&\';\n        return ArrayResponse<Message>{\n            request(Get,\n                path("channels/{channel.id}/messages{key}{limit}", { channelID, key,\n                (trueLimit != 0 ? "limit=" + std::to_string(trueLimit) : "") })\n            )\n        };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::getMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{ request(Get, path("channels/{channel.id}/messages/{message.id}", { channelID, messageID }), settings) };\n    }\n\n    std::string convertEmojiToURL(const std::string emoji) {\n        if(emoji.empty() || emoji[0] == \'%\')\n            return emoji; //no need to convert\n        return escapeURL(emoji);\n    }\n\n    BoolResponse BaseDiscordClient::addReaction(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji, RequestSettings<BoolResponse> settings) {\n        return { request(Put, path("channels/{channel.id}/messages/{message.id}/reactions/{emoji}/@me", { channelID, messageID, convertEmojiToURL(emoji) }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::removeReaction(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji, Snowflake<User> userID) {\n        return { request(Delete, path("channels/{channel.id}/messages/{message.id}/reactions/{emoji}/{user.id}", { channelID, messageID, convertEmojiToURL(emoji), userID })), EmptyRespFn() };\n    }\n\n    ArrayResponse<Reaction> BaseDiscordClient::getReactions(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji, RequestSettings<ArrayResponse<Reaction>> settings) {\n        return ArrayResponse<Reaction>{ request(Get, path("channels/{channel.id}/messages/{message.id}/reactions/{emoji}", { channelID, messageID, convertEmojiToURL(emoji) }), settings) };\n    }\n\n    StandardResponse BaseDiscordClient::removeAllReactions(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<StandardResponse> settings) {\n        return StandardResponse{ request(Delete, path("channels/{channel.id}/messages/{message.id}/reactions", { channelID, messageID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::editChannelPermissions(Snowflake<Channel> channelID, Snowflake<Overwrite> overwriteID, int allow, int deny, std::string type) {\n        return { request(\n            Put,\n            path("channels/{channel.id}/permissions/{overwrite.id}", { channelID, overwriteID }),\n            json::createJSON({\n                { "allow", std::to_string(allow) },\n                { "deny", std::to_string(deny) },\n                { "type", json::string(type) }\n        })), EmptyRespFn() };\n    }\n\n    ArrayResponse<Invite> BaseDiscordClient::getChannelInvites(Snowflake<Channel> channelID, RequestSettings<ArrayResponse<Invite>> settings) {\n        return ArrayResponse<Invite>{ request(Get, path("channels/{channel.id}/invites", { channelID }), settings) };\n    }\n\n    ObjectResponse<Invite> BaseDiscordClient::createChannelInvite(Snowflake<Channel> channelID, const uint64_t maxAge, const uint64_t maxUses, const bool temporary, const bool unique) {\n        return ObjectResponse<Invite>{\n            request(Post, path("channels/{channel.id}/invites", { channelID }),\n                json::createJSON({\n                    {"max_age", json::optionalUInteger(maxAge) },\n                    {"max_uses", json::optionalUInteger(maxUses) },\n                    { "temporary", temporary ? "true" : ""},\n                    { "unique", unique ? "true" : ""}\n                }\n            ))\n        };\n    }\n\n    BoolResponse BaseDiscordClient::removeChannelPermission(Snowflake<Channel> channelID, std::string ID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("channels/{channel.id}/permissions/{overwrite.id}", { channelID, ID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::sendTyping(Snowflake<Channel> channelID, RequestSettings<BoolResponse> settings) {\n        return { request(Post, path("channels/{channel.id}/typing", { channelID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<Message> BaseDiscordClient::getPinnedMessages(Snowflake<Channel> channelID, RequestSettings<ArrayResponse<Message>> settings) {\n        return ArrayResponse<Message>{ request(Get, path("channels/{channel.id}/pins", { channelID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::pinMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<BoolResponse> settings) {\n        return { request(Put, path("channels/{channel.id}/pins/{message.id}", { channelID, messageID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::unpinMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("channels/{channel.id}/pins/{message.id}", { channelID, messageID }), settings), EmptyRespFn() };\n    }\n\n    StandardResponse BaseDiscordClient::addRecipient(Snowflake<Channel> channelID, Snowflake<User> userID, RequestSettings<StandardResponse> settings) {\n        return StandardResponse{ request(Put, path("channels/{channel.id}/recipients/{user.id}", { channelID, userID }), settings) };\n    }\n\n    StandardResponse BaseDiscordClient::removeRecipient(Snowflake<Channel> channelID, Snowflake<User> userID, RequestSettings<StandardResponse> settings) {\n        return StandardResponse{ request(Delete, path("channels/{channel.id}/recipients/{user.id}", { channelID, userID }), settings) };\n    }\n\n    //\n    //server functions\n    //\n    ObjectResponse<Channel> BaseDiscordClient::createTextChannel(Snowflake<Server> serverID, std::string name, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{\n            request(Post, path("guilds/{guild.id}/channels", { serverID }), settings, "{\\"name\\": " + json::string(name) + ", \\"type\\": \\"text\\"}")\n        };\n    }\n\n    ArrayResponse<Channel> BaseDiscordClient::editChannelPositions(Snowflake<Server> serverID, std::vector<std::pair<std::string, uint64_t>> positions, RequestSettings<ArrayResponse<Channel>> settings) {\n        return ArrayResponse<Channel>{ request(Patch, path("guilds/{guild.id}/channels", { serverID }), getEditPositionString(positions)) };\n    }\n\n    ObjectResponse<ServerMember> SleepyDiscord::BaseDiscordClient::getMember(Snowflake<Server> serverID, Snowflake<User> userID, RequestSettings<ObjectResponse<ServerMember>> settings) {\n        return ObjectResponse<ServerMember>{ request(Get, path("guilds/{guild.id}/members/{user.id}", { serverID, userID }), settings) };\n    }\n\n    ArrayResponse<ServerMember> BaseDiscordClient::listMembers(Snowflake<Server> serverID, uint16_t limit, std::string after, RequestSettings<ArrayResponse<ServerMember>> settings) {\n        //Todo better Query String Params support\n        std::string limitParm = limit != 0 ? "?limit=" + std::to_string(limit) : "";\n        std::string afterParm = after != "" ? "after=" + after : "";\n        if (afterParm != "" && limitParm != "") limitParm += \'&\';\n        else if (afterParm != "" && limitParm == "") limitParm += \'?\';\n        return ArrayResponse<ServerMember>{ request(Get, path("guilds/{guild.id}/members{limit}{after}", { serverID, limitParm, afterParm }), settings) };\n    }\n\n    ObjectResponse<ServerMember> BaseDiscordClient::addMember(Snowflake<Server> serverID, Snowflake<User> userID, std::string accesToken, std::string nick, std::vector<Role> roles, bool mute, bool deaf) {\n        std::string rolesString = "";\n        if (roles.empty()){\n            rolesString = "";\n        } else {\n            int i = -1;\n            std::vector<std::string> values(roles.size());\n            for (Role role : roles) {\n                values[++i] = json::createJSON({\n                    { "id"         , json::string  (role.ID         ) },\n                    { "name"       , json::string  (role.name       ) },\n                    { "color"      , json::UInteger(role.color      ) },\n                    { "hoist"      , json::boolean (role.hoist      ) },\n                    { "position"   , json::integer (role.position   ) },\n                    { "managed"    , json::boolean (role.managed    ) },\n                    { "mentionable", json::boolean (role.mentionable) }\n                });\n            }\n            rolesString = json::createJSONArray(values);\n        }\n\n        return ObjectResponse<ServerMember>{\n            request(Put, path("guilds/{guild.id}/members/{user.id}"), json::createJSON({\n                { "access_token", json::string (accesToken) },\n                { "nick"        , json::string (nick)       },\n                { "roles"       , rolesString               },\n                { "mute"        , json::boolean(mute)       },\n                { "deaf"        , json::boolean(deaf)       }\n            })) \n        };\n    }\n\n    BoolResponse BaseDiscordClient::editMember(Snowflake<Server> serverID, Snowflake<User> userID, std::string nickname, std::vector<Snowflake<Role>> roles, int8_t mute, int8_t deaf, Snowflake<Channel> channelID) {\n        const std::string muteString = mute != -1 ? json::boolean(mute) : "";\n        const std::string deafString = deaf != -1 ? json::boolean(deaf) : "";\n\n        return { request(Patch, path("guilds/{guild.id}/members/{user.id}", { serverID, userID }), json::createJSON({\n            { "nick"      , json::string(nickname)       },\n            { "roles"     , json::createJSONArray(roles) },\n            { "mute"      , muteString                   },\n            { "deaf"      , deafString                   },\n            { "channel_id", json::string(channelID)      },\n        })), EmptyRespFn() };\n    }\n\n    ArrayResponse<Role> BaseDiscordClient::editRolePosition(Snowflake<Server> serverID, std::vector<std::pair<std::string, uint64_t>> positions, RequestSettings<ArrayResponse<Role>> settings) {\n        return ArrayResponse<Role>{ request(Patch, path("guilds/{guild.id}/roles", { serverID }), settings, getEditPositionString(positions)) };\n    }\n\n\n    StringResponse BaseDiscordClient::editRole(Snowflake<Server> serverID, Snowflake<Role> roleID, std::string name, Permission permissions, uint32_t color, int8_t hoist, int8_t mentionable) {\n        const std::string colorString       = color       >> 24 == 0 ? std::to_string(color      ) : "";    //if over 24 bits, do not change color\n        const std::string hoistString       = hoist       >> 1  == 0 ? json::boolean (hoist      ) : "";    //if larger then 1 bit, do change hoist\n        const std::string mentionableString = mentionable >> 1  == 0 ? json::boolean (mentionable) : "";\n\n        return StringResponse{\n            request(Patch, path("guilds/{guild.id}/roles/{role.id}", { serverID, roleID }), json::createJSON({\n                { "name"       , json::string(name)         },\n                { "permissions", json::integer(permissions) },\n                { "color"      , colorString                },\n                { "hoist"      , hoistString                },\n                { "mentionable", mentionableString          }\n            }))\n        };\n    }\n\n    BoolResponse SleepyDiscord::BaseDiscordClient::deleteRole(Snowflake<Server> serverID, Snowflake<Role> roleID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/roles/{role.id}", { serverID, roleID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::muteServerMember(Snowflake<Server> serverID, Snowflake<User> userID, bool mute, RequestSettings<BoolResponse> settings) {\n        return { request(Patch, path("guilds/{guild.id}/members/{user.id}", { serverID, userID }), settings, mute ? "{\\"mute\\":true}" : "{\\"mute\\":false}"), EmptyRespFn() };\n    }\n\n    //needs ablily to turn channel into json\n    /*ObjectResponse<Server> BaseDiscordClient::createServer(std::string name, std::string region, std::string icon, int verificationLevel, int defaultMessageNotifications, int explicitContentLevel, std::vector<Role> roles, std::vector<Channel> channels) {\n        request(Post, "guilds", json::createJSON({\n            { "name"                         , json::string (name) },\n            { "region"                       , json::string(region) },\n            { "icon"                         , json::string(icon) },\n            { "verification_level"           , json::integer(verificationLevel) },\n            { "default_message_notifications", json::integer(defaultMessageNotifications) },\n            { "explicit_content_filter"      , json::integer(explicitContentLevel) },\n            { "roles"                        , json::createJSONArray(roles) },\n            { "channels"                     , json::createJSONArray(channels) }\n        }));\n    }*/\n\n    ObjectResponse<Server> BaseDiscordClient::getServer(Snowflake<Server> serverID, RequestSettings<ObjectResponse<Server>> settings) {\n        return ObjectResponse<Server>{ request(Get, path("guilds/{guild.id}", { serverID }), settings) };\n    }\n\n    ObjectResponse<Server> BaseDiscordClient::deleteServer(Snowflake<Server> serverID, RequestSettings<ObjectResponse<Server>> settings) {\n        return ObjectResponse<Server>{ request(Delete, path("guilds/{guild.id}", { serverID }), settings) };\n    }\n\n    ArrayResponse<Channel> SleepyDiscord::BaseDiscordClient::getServerChannels(Snowflake<Server> serverID, RequestSettings<ArrayResponse<Channel>> settings) {\n        return ArrayResponse<Channel>{ request(Get, path("guilds/{guild.id}/channels", { serverID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::editNickname(Snowflake<Server> serverID, std::string newNickname, RequestSettings<BoolResponse> settings) {\n        return { request(Patch, path("guilds/{guild.id}/members/@me/nick", { serverID }), settings, "{\\"nick\\":" + json::string(newNickname) + "}"), StandardRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::addRole(Snowflake<Server> serverID, Snowflake<User> userID, Snowflake<Role> roleID, RequestSettings<BoolResponse> settings) {\n        return { request(Put, path("guilds/{guild.id}/members/{user.id}/roles/{role.id}", { serverID, userID, roleID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::removeRole(Snowflake<Server> serverID, Snowflake<User> userID, Snowflake<Role> roleID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/members/{user.id}/roles/{role.id}", { serverID, userID, roleID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::kickMember(Snowflake<Server> serverID, Snowflake<User> userID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/members/{user.id}", { serverID, userID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<User> BaseDiscordClient::getBans(Snowflake<Server> serverID, RequestSettings<ArrayResponse<User>> settings) {\n        return ArrayResponse<User>{ request(Get, path("guilds/{guild.id}/bans", { serverID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::banMember(Snowflake<Server> serverID, Snowflake<User> userID, int deleteMessageDays, std::string reason, RequestSettings<BoolResponse> settings) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        auto& allocator = doc.GetAllocator();\n        if (deleteMessageDays == -1)\n            doc.AddMember("delete_message_days", deleteMessageDays, allocator);\n        if (!reason.empty()) {\n            rapidjson::Value reasonValue;\n            reasonValue.SetString(reason.c_str(), reason.length());\n            doc.AddMember("reason", reasonValue, allocator);\n        }\n        return { request(Put, path("guilds/{guild.id}/bans/{user.id}", { serverID, userID }), settings, json::stringify(doc)), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::unbanMember(Snowflake<Server> serverID, Snowflake<User> userID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/bans/{user.id}", { serverID, userID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<Role> BaseDiscordClient::getRoles(Snowflake<Server> serverID, RequestSettings<ArrayResponse<Role>> settings) {\n        return ArrayResponse<Role>{ request(Get, path("guilds/{guild.id}/roles", { serverID }), settings) };\n    }\n\n    ObjectResponse<Role> BaseDiscordClient::createRole(Snowflake<Server> serverID, std::string name, Permission permissions, unsigned int color, bool hoist, bool mentiionable) {\n        return ObjectResponse<Role>{\n            request(Post, path("guilds/{guild.id}/roles", { serverID }), json::createJSON({\n                { "name"       , json::string (name        ) },\n                { "permissions", json::integer(permissions ) },\n                { "color"      , json::integer(color       ) },\n                { "hoist"      , json::boolean(hoist       ) },\n                { "mentionable", json::boolean(mentiionable) }\n            }))\n        };\n    }\n\n    StandardResponse BaseDiscordClient::pruneMembers(Snowflake<Server> serverID, const unsigned int numOfDays, RequestSettings<StandardResponse> settings) {\n        if (numOfDays == 0) return StandardResponse{ BAD_REQUEST };\n        return StandardResponse{ request(Post, path("guilds/{guild.id}/prune", { serverID }), settings, "{\\"days\\":" + std::to_string(numOfDays) + \'}\') };\n    }\n\n    ArrayResponse<VoiceRegion> BaseDiscordClient::getVoiceRegions(RequestSettings<ArrayResponse<VoiceRegion>> settings) {\n        return ArrayResponse<VoiceRegion>{ request(Get, path("guilds/{guild.id}/regions"), settings) };\n    }\n\n    ArrayResponse<Invite> BaseDiscordClient::getServerInvites(Snowflake<Server> serverID, RequestSettings<ArrayResponse<Invite>> settings) {\n        return ArrayResponse<Invite>{ request(Get, path("guilds/{guild.id}/invites", { serverID }), settings) };\n    }\n\n    StringResponse BaseDiscordClient::getIntegrations(Snowflake<Server> serverID, RequestSettings<StringResponse> settings) {\n        return StringResponse{ request(Get, path("guilds/{guild.id}/integrations", { serverID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::createIntegration(Snowflake<Server> serverID, std::string type, std::string integrationID, RequestSettings<BoolResponse> settings) {\n        return { request(Post, path("guilds/{guild.id}/integrations", { serverID }), settings, json::createJSON({\n            { "type", json::string(type) },\n            { "id", json::string(integrationID) }\n        })), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::editIntergration(Snowflake<Server> serverID, std::string integrationID, int expireBegavior, int expireGracePeriod, bool enbleEmoticons) {\n        return { request(Patch, path("guilds/{guild.id}/integrations/{integration.id}", { serverID, integrationID }), json::createJSON({\n            { "expire_behavior", json::integer(expireBegavior) },\n            { "expire_grace_period", json::integer(expireGracePeriod) },\n            { "enable_emoticons", json::boolean(enbleEmoticons) }\n        })), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::deleteIntegration(Snowflake<Server> serverID, std::string integrationID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/integrations/{integration.id}", { serverID, integrationID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::syncIntegration(Snowflake<Server> serverID, std::string integrationID, RequestSettings<BoolResponse> settings) {\n        return { request(Post, path("guilds/{guild.id}/integrations/{integration.id}/sync", { serverID, integrationID }), settings), EmptyRespFn() };\n    }\n\n    ObjectResponse<ServerEmbed> BaseDiscordClient::getServerEmbed(Snowflake<Server> serverID, RequestSettings<ObjectResponse<ServerEmbed>> settings) {\n        return ObjectResponse<ServerEmbed>{ request(Get, path("guilds/{guild.id}/embed", { serverID }), settings) };\n    }\n\n    //\n    //Invite functions\n    //\n    ObjectResponse<Invite> BaseDiscordClient::inviteEndpoint(RequestMethod method, std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings) {\n        return ObjectResponse<Invite>{ request(method, path("invites/{invite.code}", { inviteCode }), settings) };\n    }\n\n    ObjectResponse<Invite> BaseDiscordClient::getInvite(std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings) {\n        return inviteEndpoint(Get, inviteCode, settings);\n    }\n\n    ObjectResponse<Invite> BaseDiscordClient::deleteInvite(std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings) {\n        return inviteEndpoint(Delete, inviteCode, settings);\n    }\n\n    ObjectResponse<Invite> BaseDiscordClient::acceptInvite(std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings) {\n        return inviteEndpoint(Post, inviteCode, settings);\n    }\n    //\n    //User functions\n    //\n    ObjectResponse<User> BaseDiscordClient::getCurrentUser(RequestSettings<ObjectResponse<User>> settings) {\n        return ObjectResponse<User>{ request(Get, "users/@me", settings) };\n    }\n\n    ObjectResponse<User> BaseDiscordClient::getUser(Snowflake<User> userID, RequestSettings<ObjectResponse<User>> settings) {\n        return ObjectResponse<User>{ request(Get, path("users/{user.id}", { userID }), settings) };\n    }\n\n    ArrayResponse<Server> BaseDiscordClient::getServers(RequestSettings<ArrayResponse<Server>> settings) {\n        return ArrayResponse<Server>{ request(Get, "users/@me/guilds", settings) };\n    }\n\n    BoolResponse BaseDiscordClient::leaveServer(Snowflake<Server> serverID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("users/@me/guilds/{guild.id}", { serverID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<Channel> BaseDiscordClient::getDirectMessageChannels(RequestSettings<ArrayResponse<Channel>> settings) {\n        return ArrayResponse<Channel>{ request(Get, "users/@me/channels", settings) };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::createDirectMessageChannel(std::string recipientID, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{ request(Post, "users/@me/channels", settings, json::createJSON({ { "recipient_id", recipientID } })) };\n    }\n\n    ArrayResponse<Connection> BaseDiscordClient::getUserConnections(RequestSettings<ArrayResponse<Connection>> settings) {\n        return ArrayResponse<Connection>{ request(Get, "users/@me/connections", settings) };\n    }\n\n    //\n    //Webhook functions\n    //\n    ObjectResponse<Webhook> BaseDiscordClient::createWebhook(Snowflake<Channel> channelID, std::string name, std::string avatar, RequestSettings<ObjectResponse<Webhook>> settings) {\n        return ObjectResponse<Webhook>{ request(Post, path("channels/{channel.id}/webhooks", { channelID }), settings, json::createJSON({\n            {"name", json::string(name)},\n            {"avatar", json::string(avatar)}\n        })) };\n    }\n\n    ArrayResponse<Webhook> BaseDiscordClient::getChannelWebhooks(Snowflake<Channel> channelID, RequestSettings<ArrayResponse<Webhook>> settings) {\n        return ArrayResponse<Webhook>{ request(Get, path("channels/{channel.id}/webhooks", { channelID }), settings) };\n    }\n\n    ArrayResponse<Webhook> BaseDiscordClient::getServerWebhooks(Snowflake<Server> serverID, RequestSettings<ArrayResponse<Webhook>> settings) {\n        return ArrayResponse<Webhook>{ request(Get, path("guilds/{guild.id}/webhooks", { serverID }), settings) };\n    }\n\n    inline const char* optionalWebhookToken(std::string webhookToken) {\n        return webhookToken != "" ? "webhooks/{webhook.id}/{webhook.token}" : "webhooks/{webhook.id}";\n    }\n\n    ObjectResponse<Webhook> BaseDiscordClient::getWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, RequestSettings<ObjectResponse<Webhook>> settings) {\n        return ObjectResponse<Webhook>{ request(Get, path(optionalWebhookToken(webhookToken), { webhookID, webhookToken }), settings) };\n    }\n\n    ObjectResponse<Webhook> BaseDiscordClient::editWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, std::string name, std::string avatar) {\n        return ObjectResponse<Webhook>{ request(Patch, path(optionalWebhookToken(webhookToken), { webhookID, webhookToken }), json::createJSON({\n            { "name", json::string(name) },\n            { "avatar", json::string(avatar) }\n        })) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path(optionalWebhookToken(webhookToken), { webhookID, webhookToken }), settings), EmptyRespFn() };\n    }\n\n    //excute webhook\n\n    ObjectResponse<Webhook> BaseDiscordClient::requestExecuteWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, std::pair<std::string, std::string> pair, bool wait, std::string username, std::string avatar_url, bool tts) {\n        return ObjectResponse<Webhook>{\n            request(Post, path("webhooks/{webhook.id}/{webhook.token}{wait}", { webhookID, webhookToken, (wait ? "?around=true" : "") }), json::createJSON({\n                pair,\n                { "username"  , json::string(username  ) },\n                { "avatar_url", json::string(avatar_url) },\n                { "tts"       , (tts ? "true" : "")      }\n            })) };\n    }\n\n    ObjectResponse<Webhook> BaseDiscordClient::executeWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, std::string content, bool wait, std::string username, std::string avatar_url, bool tts) {\n        return ObjectResponse<Webhook>{ requestExecuteWebhook(webhookID, webhookToken, { "content", json::string(content) }, wait, username, avatar_url, tts) };\n    }\n\n    //Webhook SleepyDiscord::BaseDiscordClient::executeWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, std::vector<Embed> embeds, bool wait, std::string username, std::string avatar_url bool tts) {\n    //  \n    //  return requestExecuteWebhook(webhookID, webhookToken, { "embeds", crazy stuff happens here }, wait, username, avatar_url, tts);\n    //}\n    \n    ObjectResponse<Webhook> BaseDiscordClient::executeWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, filePathPart file, bool /*wait*/, std::string username, std::string avatar_url, bool tts) {\n        return ObjectResponse<Webhook>{ request(Post, path("webhooks/{webhook.id}/{webhook.token}", { webhookID, webhookToken }), "", {\n            { "file"      , filePathPart(file)  },\n            { "username"  , username            },\n            { "avatar_url", avatar_url          },\n            { "tts"       , (tts ? "true" : "") }\n        }) };\n    }\n}\n')),Object(o.b)("hr",null),Object(o.b)("p",null,"Updated on  9 February 2021 at 07:04:59 Eastern Standard Time"))}d.isMDXComponent=!0},317:function(e,n,s){"use strict";s.d(n,"a",(function(){return g})),s.d(n,"b",(function(){return h}));var t=s(0),r=s.n(t);function o(e,n,s){return n in e?Object.defineProperty(e,n,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[n]=s,e}function i(e,n){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),s.push.apply(s,t)}return s}function a(e){for(var n=1;n<arguments.length;n++){var s=null!=arguments[n]?arguments[n]:{};n%2?i(Object(s),!0).forEach((function(n){o(e,n,s[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):i(Object(s)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(s,n))}))}return e}function l(e,n){if(null==e)return{};var s,t,r=function(e,n){if(null==e)return{};var s,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)s=o[t],n.indexOf(s)>=0||(r[s]=e[s]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)s=o[t],n.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(r[s]=e[s])}return r}var c=r.a.createContext({}),d=function(e){var n=r.a.useContext(c),s=n;return e&&(s="function"==typeof e?e(n):a(a({},n),e)),s},g=function(e){var n=d(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},p=r.a.forwardRef((function(e,n){var s=e.components,t=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),g=d(s),p=t,h=g["".concat(i,".").concat(p)]||g[p]||u[p]||o;return s?r.a.createElement(h,a(a({ref:n},c),{},{components:s})):r.a.createElement(h,a({ref:n},c))}));function h(e,n){var s=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=s.length,i=new Array(o);i[0]=p;var a={};for(var l in n)hasOwnProperty.call(n,l)&&(a[l]=n[l]);a.originalType=e,a.mdxType="string"==typeof e?e:t,i[1]=a;for(var c=2;c<o;c++)i[c]=s[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,s)}p.displayName="MDXCreateElement"}}]);